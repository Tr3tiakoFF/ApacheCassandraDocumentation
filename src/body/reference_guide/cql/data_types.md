# Типи даних

CQL — це типізована мова, яка підтримує широкий набір типів даних, включаючи нативні типи, колекції, користувацькі типи, кортежі та користувацькі типи:

```bnf
cql_type::= native_type| collection_type| user_defined_type | tuple_type | custom_type
```

## Нативні типи

Нижче наведені нативні типи, які підтримуються в CQL:

```bnf
native_type ::= ASCII | BIGINT | BLOB | BOOLEAN | COUNTER | DATE | DECIMAL | DOUBLE | DURATION | FLOAT | INET | INT | SMALLINT | TEXT | TIME | TIMESTAMP | TIMEUUID | TINYINT | UUID | VARCHAR | VARINT | VECTOR
```

Наступна таблиця надає додаткову інформацію про нативні типи даних та типи констант, які вони підтримують:

| Тип         | Підтримувані константи     | Опис                                                                                          |
|-------------|----------------------------|----------------------------------------------------------------------------------------------|
| **ascii**   | рядок                     | ASCII-рядок символів                                                                         |
| **bigint**  | ціле число                | 64-бітне знакове ціле число                                                                  |
| **blob**    | blob                      | Довільні байти (без перевірки)                                                               |
| **boolean** | булеве значення           | `true` або `false`                                                                           |
| **counter** | ціле число                | Лічильник (64-бітне знакове значення). Див. [лічильники](#лічильники).                       |
| **date**    | ціле число, рядок         | Дата (без відповідного часу). Див. [дата](#дата).                                            |
| **decimal** | ціле число, число з плаваючою точкою | Десяткове число з варіативною точністю                                                      |
| **double**  | ціле число, число з плаваючою точкою | 64-бітне число з плаваючою точкою у форматі IEEE-754                                        |
| **duration**| тривалість                | Тривалість з точністю до наносекунд. Див. [тривалість](#тривалість).                         |
| **float**   | ціле число, число з плаваючою точкою | 32-бітне число з плаваючою точкою у форматі IEEE-754                                        |
| **inet**    | рядок                     | IP-адреса (IPv4 — 4 байти або IPv6 — 16 байтів). Вводиться у вигляді рядків.                 |
| **int**     | ціле число                | 32-бітне знакове ціле число                                                                  |
| **smallint**| ціле число                | 16-бітне знакове ціле число                                                                  |
| **text**    | рядок                     | Рядок, закодований у форматі UTF8                                                            |
| **time**    | ціле число, рядок         | Час (без відповідної дати) з точністю до наносекунд. Див. [час](#час).                       |
| **timestamp**| ціле число, рядок        | Мітка часу (дата та час) з точністю до мілісекунд. Див. [мітка часу](#мітка-часу).           |
| **timeuuid**| uuid                      | UUID версії 1, зазвичай використовується як "унікальна мітка часу". Див. [timeuuid](#timeuuid). |
| **tinyint** | ціле число                | 8-бітне знакове ціле число                                                                   |
| **uuid**    | uuid                      | UUID будь-якої версії                                                                        |
| **varchar** | рядок                     | Рядок, закодований у форматі UTF8                                                            |
| **varint**  | ціле число                | Ціле число з довільною точністю                                                              |
| **vector**  | число з плаваючою точкою  | Фіксований масив чисел з плаваючою точкою. Додано у Cassandra 5.0 (CASSANDRA-18504).          |

## Лічильники

Тип `counter` використовується для визначення колонок-лічильників. Колонка-лічильник — це колонка, значення якої є 64-бітним знаковим цілим числом, для якого підтримуються дві операції: збільшення та зменшення (див. синтаксис у команді UPDATE). Зверніть увагу, що значення лічильника не можна встановити: лічильник не існує до першого збільшення або зменшення, і ця перша операція виконується так, ніби попереднє значення дорівнювало 0.

### Обмеження лічильників

- Вони не можуть бути частиною 'PRIMARY KEY' таблиці.
- Таблиця, яка містить лічильник, може містити лише лічильники. Тобто всі колонки таблиці, за винятком 'PRIMARY KEY', повинні мати тип `counter`, або жодна з них.
- Лічильники не підтримують термін дії (expiration).
- Видалення лічильників підтримується, але гарантується лише для першого видалення. Повторне оновлення видаленого лічильника може спричинити непередбачувану поведінку.
- Оновлення лічильників не є ідемпотентними. Якщо оновлення лічильника несподівано не вдалося (тайм-аут або втрата зв'язку з вузлом-координатором), клієнт не може дізнатися, чи було оновлення застосовано. Повторне оновлення може призвести до помилкового обчислення.

## Робота з мітками часу (Timestamps)

Значення типу `timestamp` кодуються у вигляді 64-бітних знакових цілих чисел, які представляють кількість мілісекунд з початку епохи: 1 січня 1970 року, 00:00:00 GMT.

Мітки часу можуть бути введені у CQL як ціле число або рядок, що представляє дату у форматі [ISO 8601](https://www.iso.org/obp/ui/#iso:std:iso:8601:-1:ed-1:v1:en). Наприклад, наступні значення є дійсними для 2 березня 2011 року, 04:05 AM, GMT:

- `1299038700000`
- `'2011-02-03 04:05+0000'`
- `'2011-02-03T04:05:00.000+0000'`

### Примітки щодо часових поясів:
- `+0000` — це специфікація часового поясу [RFC 822](https://datatracker.ietf.org/doc/html/rfc822); +0000 відповідає GMT.
- Якщо часовий пояс пропущено (наприклад, `'2011-02-03 04:05:00'`), дата інтерпретується згідно з налаштуванням часового поясу вузла Cassandra.
- Якщо вказується лише дата (наприклад, `'2011-02-03'`), час за замовчуванням буде 00:00:00. Якщо цікавить лише дата, краще використовувати тип `date`.

## Тип дат

Значення типу `date` кодуються у вигляді 32-бітних беззнакових цілих чисел, які представляють кількість днів із середини діапазону (2^31). Початок епохи — 1 січня 1970 року.

Введення даних типу `date` можливе у вигляді цілого числа або рядка формату `yyyy-mm-dd` (наприклад, `'2011-02-03'`).

## Часовий тип

Значення типу `time` кодуються у вигляді 64-бітних знакових цілих чисел, що представляють кількість наносекунд із півночі.

Можливі формати введення:
- Ціле число
- Рядок у форматі `hh:mm:ss[.fffffffff]` (наприклад, `'08:12:54.123456789'`).

## Тип відрізку часу

Значення типу `duration` кодуються у вигляді трьох цілих чисел змінної довжини:
1. Кількість місяців
1. Кількість днів
1. Кількість наносекунд

### Формати введення:
- `(кількість одиниць)+(одиниця)` (наприклад, `12h30m`). Одиниці:
  - `y`: роки
  - `mo`: місяці
  - `w`: тижні
  - `d`: дні
  - `h`: години
  - `m`: хвилини
  - `s`: секунди
  - `ms`: мілісекунди
  - `us`/`µs`: мікросекунди
  - `ns`: наносекунди
- Формати [ISO 8601](https://www.iso.org/obp/ui/#iso:std:iso:8601:-1:ed-1:v1:en):
  - `P[n]Y[n]M[n]DT[n]H[n]M[n]S`
  - `P[n]W`

### Обмеження:
- Колонки типу `duration` не можна використовувати у PRIMARY KEY таблиці.
- `1d` не дорівнює `24h`, оскільки підтримується коректне врахування літнього часу.

### Приклади:
```sql
INSERT INTO RiderResults (rider, race, result)
   VALUES ('Christopher Froome', 'Tour de France', 89h4m48s);
INSERT INTO RiderResults (rider, race, result)
   VALUES ('BARDET Romain', 'Tour de France', PT89H8M53S);
INSERT INTO RiderResults (rider, race, result)
   VALUES ('QUINTANA Nairo', 'Tour de France', P0000-00-00T89:09:09);
```

## Колекції

CQL підтримує три типи колекцій: мапи (maps), множини (sets) і списки (lists). Типи цих колекцій визначаються так:

```bnf
collection_type ::= MAP '<' cql_type ',' cql_type '>' | SET '<' cql_type '>' | LIST '<' cql_type '>'
```

Значення для цих колекцій можна задавати за допомогою літералів:

```bnf
collection_literal ::= map_literal | set_literal | list_literal map_literal ::= '{' [ term ':' term (',' term ':' term)* ] '}' set_literal ::= '{' [ term (',' term)* ] '}' list_literal ::= '[' [ term (',' term)* ] ']'
```


Важливо: у літералах колекцій не підтримуються `bind_marker` та `NULL`.

### Основні характеристики

Колекції призначені для зберігання або денормалізації відносно невеликих обсягів даних. Вони добре підходять для таких задач, як "номери телефонів певного користувача" або "мітки, застосовані до електронного листа". Проте, якщо дані можуть рости необмежено ("всі повідомлення, надіслані користувачем", "події, зареєстровані сенсором"), краще створити окрему таблицю з кластерними колонками.

#### Обмеження та особливості:
- Індивідуальні колекції не мають внутрішніх індексів. Для доступу до одного елемента потрібно зчитувати всю колекцію.
- Вставка елементів у множини (sets) і мапи (maps) не вимагає читання перед записом, але деякі операції зі списками (lists) потребують цього.
- Операції над списками не завжди є ідемпотентними, тому їх повторення у разі тайм-ауту може бути проблематичним.
- Використання однієї колекції для зберігання великих обсягів даних є антипатерном.

### Мапи

Мапа — це впорядкована колекція пар ключ-значення, де ключі унікальні, а сортування здійснюється за ключами.

#### Приклад створення та вставки даних:

```sql
CREATE TABLE users (
   id text PRIMARY KEY,
   name text,
   favs map<text, text> // Мапа з текстовими ключами і значеннями
);

INSERT INTO users (id, name, favs)
   VALUES ('jsmith', 'John Smith', { 'fruit' : 'Apple', 'band' : 'Beatles' });
```

#### Оновлення мапи:
- Замінити всю мапу:
```sql
UPDATE users SET favs = { 'fruit' : 'Banana' } WHERE id = 'jsmith';
```
- Додати або оновити елементи:
```sql
UPDATE users SET favs['author'] = 'Ed Poe' WHERE id = 'jsmith';
UPDATE users SET favs = favs + { 'movie' : 'Casablanca', 'band' : 'ZZ Top' } WHERE id = 'jsmith';
```
- Видалити елементи:
```sql
DELETE favs['author'] FROM users WHERE id = 'jsmith';
UPDATE users SET favs = favs - { 'movie', 'band' } WHERE id = 'jsmith';
```
Для видалення декількох елементів мапи використовується множина ключів.

#### TTL для мап:

TTL застосовується лише до нових елементів:

```sql
UPDATE users USING TTL 10 SET favs['color'] = 'green' WHERE id = 'jsmith';
```

### Множини (Sets)
Множина — це впорядкована колекція унікальних значень.

#### Приклад створення та вставки даних:
```sql
CREATE TABLE images (
   name text PRIMARY KEY,
   owner text,
   tags set<text> // Множина текстових значень
);

INSERT INTO images (name, owner, tags)
   VALUES ('cat.jpg', 'jsmith', { 'pet', 'cute' });
```

#### Оновлення множини:
- Замінити всю множину:
```sql
UPDATE images SET tags = { 'kitten', 'cat', 'lol' } WHERE name = 'cat.jpg';
```
- Додати елементи:
```sql
UPDATE images SET tags = tags + { 'gray', 'cuddly' } WHERE name = 'cat.jpg';
```
- Видалити елементи:
```sql
UPDATE images SET tags = tags - { 'cat' } WHERE name = 'cat.jpg';
```
#### TTL для множин:

TTL застосовується лише до нових елементів.

### Списки (Lists)

Список — це впорядкована колекція неунікальних значень, де елементи впорядковуються за позицією у списку. Якщо можливо, завжди надавайте перевагу множинам (sets) замість списків.

#### Створення та вставка списків:
```sql
CREATE TABLE plays (
    id text PRIMARY KEY,
    game text,
    players int,
    scores list<int> // Список цілих чисел
);

INSERT INTO plays (id, game, players, scores)
           VALUES ('123-afde', 'quake', 3, [17, 4, 2]);
```

#### Операції зі списками:
- Повна заміна списку
```sql
UPDATE plays SET scores = [3, 9, 4] WHERE id = '123-afde';
```
- Додавання елементів у кінець або початок:
```sql
UPDATE plays SET players = 5, scores = scores + [14, 21] WHERE id = '123-afde';
UPDATE plays SET players = 6, scores = [3] + scores WHERE id = '123-afde';
```
*Операції додавання в кінець і початок не є ідемпотентними. Якщо така операція повторюється через тайм-аут, це може призвести до дублювання значень.*
- Зміна значення за певною позицією:
```sql
UPDATE plays SET scores[1] = 7 WHERE id = '123-afde';
```
- Видалення елемента за позицією:
```sql
DELETE scores[1] FROM plays WHERE id = '123-afde';
```
- Видалення всіх входжень певних значень:
```sql
UPDATE plays SET scores = scores - [12, 21] WHERE id = '123-afde';
```
*Видалення за позицією і видалення значень потребують внутрішнього читання перед записом, що може впливати на продуктивність.*

#### TTL для списків:

TTL застосовується лише до нових значень.

### Вектори (Vectors)
Вектори — це послідовності фіксованого розміру, які містять ненульові значення певного типу. Використовуються ті ж літерали, що й для списків.

#### Створення та використання векторів:
```sql
CREATE TABLE plays (
    id text PRIMARY KEY,
    game text,
    players int,
    scores vector<int, 3> // Вектор із 3 цілих чисел
);

INSERT INTO plays (id, game, players, scores)
           VALUES ('123-afde', 'quake', 3, [17, 4, 2]);
```

#### Операції з векторами:
- Повна заміна вектора
```sql
UPDATE plays SET scores = [3, 9, 4] WHERE id = '123-afde';
```
*Змінювати окремі значення у векторі або обирати окремі елементи неможливо.*

## Користувацькі типи (UDTs)

CQL підтримує створення користувацьких типів даних (User-Defined Types, UDTs).

Створення UDT:
```sql
CREATE TYPE phone (
    country_code int,
    number text
);

CREATE TYPE address (
    street text,
    city text,
    zip text,
    phones map<text, phone>
);

CREATE TABLE user (
    name text PRIMARY KEY,
    addresses map<text, frozen<address>>
);
```

### Особливості UDT:

Якщо тип уже існує, додавайте IF NOT EXISTS, щоб уникнути помилки.
UDT прив'язані до keyspace, у якому створені, і можуть використовуватися лише в ньому.
UDT зазвичай повинні бути замороженими (frozen).

### Літерали UDT:
```sql
INSERT INTO user (name, addresses)
   VALUES ('John Doe', {
     'home': {
        street: '1600 Pennsylvania Ave NW',
        city: 'Washington',
        zip: '20500',
        phones: { 'cell': { country_code: 1, number: '202 456-1111' } }
     }
  });
```

### Модифікація UDT:
- Додавання полів:
```sql
ALTER TYPE address ADD country text;
```
- Перейменування полів:
```sql
ALTER TYPE address RENAME zip TO zipcode;
```
- Видалення UDT:
```sql
DROP TYPE [IF EXISTS] address;
```
- *Тип не можна видалити, якщо він використовується у таблиці, іншому типі або функції.*

## Кортежі (Tuples)

Кортежі — це типи даних, що підтримують різні типи елементів. Вони функціонують як анонімні UDT з анонімними полями.

### Створення кортежів:
```sql
CREATE TABLE durations (
  event text,
  duration tuple<int, text>
);

INSERT INTO durations (event, duration) VALUES ('event1', (3, 'hours'));
```

Кортеж завжди є замороженим, і його не можна оновлювати частково.

## Власні типи (Custom Types)

Власні типи використовуються переважно для зворотної сумісності. Їх використання складне і не рекомендується.

### Визначення власного типу:
```sql
custom_type ::= string
```
Власний тип є рядком, що містить ім'я класу Java, який розширює клас AbstractType на сервері Cassandra.