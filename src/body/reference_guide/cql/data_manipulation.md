# Операції з даними

Цей розділ описує оператори CQL для вставки, оновлення, видалення та запиту даних.

## Оператор вибору даних

Запити даних виконуються за допомогою оператора `SELECT`:

```bnf
select_statement::= SELECT [ JSON | DISTINCT ] ( select_clause | '*' )
	FROM `table_name`
	[ WHERE `where_clause` ]
	[ GROUP BY `group_by_clause` ]
	[ ORDER BY `ordering_clause` ]
	[ PER PARTITION LIMIT (`integer` | `bind_marker`) ]
	[ LIMIT (`integer` | `bind_marker`) ]
	[ ALLOW FILTERING ]
select_clause::= `selector` [ AS `identifier` ] ( ',' `selector` [ AS `identifier` ] )
selector::== `column_name`
	| `term`
	| CAST '(' `selector` AS `cql_type` ')'
	| `function_name` '(' [ `selector` ( ',' `selector` )_ ] ')'
	| COUNT '(' '_' ')'
where_clause::= `relation` ( AND `relation` )*
relation::= column_name operator term
	'(' column_name ( ',' column_name )* ')' operator tuple_literal
	TOKEN '(' column_name# ( ',' column_name )* ')' operator term
operator::= '=' | '<' | '>' | '<=' | '>=' | '!=' | IN | CONTAINS | CONTAINS KEY
group_by_clause::= column_name ( ',' column_name )*
ordering_clause::= column_name [ ASC | DESC ] ( ',' column_name [ ASC | DESC ] )*
```

#### Приклади:
```sql
Copy code
SELECT name, occupation FROM users WHERE userid IN (199, 200, 207);
SELECT JSON name, occupation FROM users WHERE userid = 199;
SELECT name AS user_name, occupation AS user_occupation FROM users;

SELECT time, value
FROM events
WHERE event_type = 'myEvent'
  AND time > '2011-02-03'
  AND time <= '2012-01-01';

SELECT COUNT(*) AS user_count FROM users;
```

### Вибіркова частина (Selection Clause)
`select_clause` визначає, які стовпці будуть вибрані та повернені. Ця частина може включати трансформації даних.

#### Селектори
Селектором може бути:
- Назва стовпця таблиці для отримання його значень.
- Терм — значення, зазвичай вкладене в інші селектори.
- Кастинг — перетворення типу селектора.
- Функція — виклик функції з аргументами-селекторами.
- `COUNT(*)` — підрахунок усіх ненульових результатів.

#### Псевдоніми (Aliases)
Селектори можуть мати псевдоніми за допомогою ключового слова AS. У цьому випадку назва відповідного стовпця в результаті буде псевдонімом.

##### Приклад без псевдоніма:

```sql
SELECT int_as_blob(4) FROM t;
```

##### Результат:
```
 int_as_blob(4)
 ----------------
  0x00000004
```

##### Приклад із псевдонімом:
```sql
SELECT int_as_blob(4) AS four FROM t;
```

##### Результат:

```
 four
 ------
 0x00000004
```
*Псевдоніми не підтримуються в умовах WHERE чи ORDER BY. Використовуйте оригінальне ім’я стовпця.*

#### Функції `WRITETIME`, `MAXWRITETIME` і `TTL`

`SELECT` підтримує три спеціальні функції, які не можуть бути використані в інших контекстах:

- `WRITETIME`: Повертає мітку часу для значення стовпця.
- `MAXWRITETIME`: Повертає найбільшу мітку часу для значення стовпця. Для неколекційних стовпців або стовпців, які не є UDT, еквівалентна `WRITETIME`. Для колекцій або UDT повертає найбільшу мітку часу серед усіх значень у стовпці.
- `TTL`: Повертає залишковий час життя (у секундах) для значення стовпця, якщо встановлено термін життя; в іншому випадку повертає `null`.

##### Синтаксис

Кожна функція приймає лише один аргумент — назву стовпця. 

Якщо стовпець є колекцією або UDT, можна вказати селектори елементів, наприклад:

- Для діапазону елементів колекції: `WRITETIME(phones[2..4])`
- Для елементу UDT: `WRITETIME(user.name)`

##### Особливості для мультикоміркових стовпців

Функції `WRITETIME` і `TTL` можуть бути використані для мультикоміркових стовпців, таких як:
- Колекції (наприклад, списки, множини, мапи), які не є "замороженими".
- Користувацькі типи (UDT), які не є "замороженими".

У таких випадках функції повертають список значень (міток часу чи TTL) для кожної вибраної комірки.

## Умова вибору даних

Умова `WHERE` визначає, які рядки будуть вибрані в запиті. Вона задає відношення для стовпців, що входять до `PRIMARY KEY`, або для стовпців із вторинним індексом.

### Загальні правила

- Обмеження на відношення:
    - Для ключа розділу (partition key) дозволяється лише рівність (`=`) або умова `IN` (яка розглядається як рівність для одного чи кількох значень).
    - Для нерівностей ключа розділу можна використовувати функцію `TOKEN`.
    - Умова для ключа розділу повинна бути вказана перед кластеризованими стовпцями.

- Кластеризовані стовпці:
    - Відношення для кластеризованих стовпців повинно визначати неперервний набір рядків.

- CONTAINS і CONTAINS KEY:
    - `CONTAINS` використовується для колекцій (списки, множини, мапи) і застосовується до значень у колекції.
    - `CONTAINS KEY` застосовується лише до ключів мапи.

### Приклади

#### Створення таблиці

```sql
CREATE TABLE posts (
    userid text,
    blog_title text,
    posted_at timestamp,
    entry_title text,
    content text,
    category int,
    PRIMARY KEY (userid, blog_title, posted_at)
);
```
#### Дозволений запит
```sql
SELECT entry_title, content FROM posts
 WHERE userid = 'john doe'
   AND blog_title = 'John''s Blog'
   AND posted_at >= '2012-01-01' AND posted_at < '2012-01-31';
```
#### Недозволений запит
```sql
SELECT entry_title, content FROM posts
 WHERE userid = 'john doe'
   AND posted_at >= '2012-01-01' AND posted_at < '2012-01-31';
```
*Причина: Не задано значення `blog_title`, що необхідно для вибору діапазону `posted_at`.*

### Використання функції TOKEN
Функція TOKEN дозволяє виконувати запити на основі токена ключа розділу, а не його значення. Токен залежить від партиціонера, і порядок може не бути смисловим (наприклад, у RandomPartitioner).

#### Приклад:
```sql
SELECT * FROM posts
 WHERE token(userid) > token('tom') AND token(userid) < token('bob');
```

### Використання умов для кластеризованих стовпців
#### Використання кортежів для кластеризованих стовпців:
```sql
SELECT * FROM posts
 WHERE userid = 'john doe'
   AND (blog_title, posted_at) > ('John''s Blog', '2012-01-01');
```
Результат: Повертає всі рядки, що сортуються після зазначеного значення в порядку кластеризації.

#### Кортежі з умовою `IN`:
```sql
SELECT * FROM posts
 WHERE userid = 'john doe'
   AND (blog_title, posted_at) IN (('John''s Blog', '2012-01-01'), ('Extreme Chess', '2014-06-01'));
```
Результат: Повертає рядки, які відповідають будь-якому з зазначених кортежів.

### Використання `CONTAINS` і `CONTAINS KEY`
#### Для значень у колекціях:
```sql
SELECT * FROM posts
 WHERE category CONTAINS 5;
```
#### Для ключів мапи:
```sql
SELECT * FROM posts
 WHERE category CONTAINS KEY 2;
```

### Групування результатів

Опція `GROUP BY` може згрупувати всі вибрані рядки, які мають однакові значення для певного набору стовпців, в один рядок.
Використовуючи опцію `GROUP BY`, рядки можуть бути згруповані на рівні ключа розділу або кластеризованого стовпця. Таким чином, опція `GROUP BY` приймає лише стовпці первинного ключа у визначеному порядку як аргументи. Якщо стовпець первинного ключа обмежений рівністю, він не включається в `GROUP BY`.
Агрегатні функції створюють окреме значення для кожної групи. Якщо `GROUP BY` не вказано, агрегатні функції створюють одне значення для всіх рядків.
Якщо стовпець вибрано без використання агрегатної функції у запиті з `GROUP BY`, для кожної групи повертається перше знайдене значення.

### Сортування результатів

Умова `ORDER BY` визначає порядок повернення результатів. Аргументом є список імен стовпців і порядок для кожного стовпця (`ASC` для зростання і `DESC` для спадання).
Можливі варіанти сортування обмежуються кластеризованим порядком, визначеним у таблиці:
- Якщо таблиця створена без визначеного `CLUSTERING ORDER`, порядок визначається кластеризованими стовпцями або їх зворотним порядком.
- Якщо таблиця створена з визначеним `CLUSTERING ORDER`, порядок визначається цією опцією і її зворотним варіантом.

### Обмеження кількості результатів

Опція `LIMIT` в операторі `SELECT` обмежує кількість рядків, які повертаються запитом. Опція `PER PARTITION LIMIT` обмежує кількість рядків, які повертаються для заданого розділу в запиті. Обидва типи обмежень можуть використовуватися в одному запиті.

### Дозволення фільтрації

За замовчуванням CQL дозволяє лише такі запити `SELECT`, які не передбачають повного сканування всіх розділів. Якщо скануються всі розділи, повернення результатів може мати значну затримку, пропорційну обсягу даних у таблиці. Опція `ALLOW FILTERING` явно виконує повне сканування. Таким чином, продуктивність запиту може бути непередбачуваною.

Наприклад, розглянемо наступну таблицю профілів користувачів із роком народження та країною проживання. Для стовпця `birth_year` визначено вторинний індекс.

```sql
CREATE TABLE users (
    username text PRIMARY KEY,
    firstname text,
    lastname text,
    birth_year int,
    country text
);

CREATE INDEX ON users(birth_year);
```

#### Наступні запити є допустимими:

```sql
// Повертаються всі користувачі
SELECT * FROM users;

// Повертаються всі користувачі з певним роком народження
SELECT * FROM users WHERE birth_year = 1981;
```

У обох випадках продуктивність запиту пропорційна обсягу повернених даних. Перший запит повертає всі рядки, оскільки обрано всіх користувачів. Другий запит повертає лише рядки, визначені вторинним індексом, який реалізується на рівні кожного вузла; результати залежать від кількості вузлів у кластері й непрямо пропорційні обсягу збережених даних. Кількість вузлів завжди буде на декілька порядків меншою за кількість збережених профілів користувачів. Обидва запити можуть повертати дуже великі набори результатів, але додавання опції LIMIT може зменшити затримку.

#### Наступний запит буде відхилено:

```sql
SELECT * FROM users WHERE birth_year = 1981 AND country = 'FR';
```
Cassandra не може гарантувати, що великий обсяг даних не доведеться сканувати, навіть якщо результат невеликий. Якщо ви знаєте, що набір даних невеликий і продуктивність буде прийнятною, додайте ALLOW FILTERING, щоб дозволити виконання запиту:

```sql
SELECT * FROM users WHERE birth_year = 1981 AND country = 'FR' ALLOW FILTERING;
```

## Вставка даних

Вставка даних у рядок виконується за допомогою оператора `INSERT`:

```bnf
insert_statement::= INSERT INTO table_name ( names_values | json_clause )
	[ IF NOT EXISTS ]
	[ USING update_parameter ( AND update_parameter )* ]
names_values::= names VALUES tuple_literal
json_clause::= JSON string [ DEFAULT ( NULL | UNSET ) ]
names::= '(' column_name ( ',' column_name )* ')'
```

#### Приклад:
```sql
INSERT INTO NerdMovies (movie, director, main_actor, year)
   VALUES ('Serenity', 'Joss Whedon', 'Nathan Fillion', 2005)
   USING TTL 86400;

INSERT INTO NerdMovies JSON '{"movie": "Serenity", "director": "Joss Whedon", "year": 2005}';
```

Оператор `INSERT` записує один або більше стовпців для заданого рядка в таблиці. Оскільки рядок ідентифікується його первинним ключем, має бути вказаний хоча б один стовпець. Список стовпців для вставки задається через синтаксис `VALUES`. При використанні синтаксису `JSON` значення `VALUES` є необов’язковими. Більш детальну інформацію дивіться у розділі про підтримку JSON. Усі оновлення через `INSERT` виконуються атомарно та ізольовано.

На відміну від SQL, `INSERT` за замовчуванням не перевіряє попереднє існування рядка. Якщо рядок не існує, він створюється, інакше — оновлюється. Крім того, немає способу дізнатися, яка саме дія була виконана.

### Умова існування
Умова `IF NOT EXISTS` може обмежити вставку, якщо рядок уже існує. Однак слід враховувати, що використання IF NOT EXISTS має значні витрати на продуктивність, оскільки використовує механізм Paxos. Тому ця опція має використовуватися економно.

```sql
INSERT INTO NerdMovies (movie, director, year)
   VALUES ('Inception', 'Christopher Nolan', 2010)
   IF NOT EXISTS;
```

*Оператор `INSERT` не підтримує лічильники, тоді як оператор `UPDATE` це дозволяє.*

## Оновлення даних

Оновлення рядка виконується за допомогою оператора `UPDATE`:

```bnf
update_statement ::=    UPDATE table_name
                        [ USING update_parameter ( AND update_parameter )* ]
                        SET assignment( ',' assignment )*
                        WHERE where_clause
                        [ IF ( EXISTS | condition ( AND condition)*) ]
update_parameter ::= ( TIMESTAMP | TTL ) ( integer | bind_marker )
assignment: simple_selection'=' term
                `| column_name'=' column_name ( '+' | '-' ) term
                | column_name'=' list_literal'+' column_name
simple_selection ::= column_name
                        | column_name '[' term']'
                        | column_name'.' field_name
condition ::= `simple_selection operator term
```
#### Приклад:
```sql
UPDATE NerdMovies USING TTL 400
   SET director   = 'Joss Whedon',
       main_actor = 'Nathan Fillion',
       year       = 2005
 WHERE movie = 'Serenity';

UPDATE UserActions
   SET total = total + 2
   WHERE user = B70DE1D0-9908-4AE3-BE34-5573E5B09F14
     AND action = 'click';
```
Оператор `UPDATE` записує один або кілька стовпців для заданого рядка в таблиці. Умова `WHERE` використовується для вибору рядка, який потрібно оновити, і повинна включати всі стовпці первинного ключа. Стовпці, які не є первинними ключами, встановлюються за допомогою ключового слова `SET`. Усі оновлення в операторі `UPDATE` в межах одного ключа розділу виконуються атомарно та ізольовано.

На відміну від SQL, `UPDATE` за замовчуванням не перевіряє попереднє існування рядка. Рядок створюється, якщо його не існувало раніше, і оновлюється в іншому випадку. Крім того, немає способу дізнатися, яка саме дія була виконана.

### Умова
Умова `IF` може бути використана для вибору, чи буде рядок оновлено, якщо виконана певна умова. Однак, як і умова `IF` `NOT EXISTS`, її використання може спричинити значні витрати продуктивності.

### Щодо призначення SET:
- `c = c + 3` збільшує/зменшує лічильники. Це єдина допустима операція. Ім’я стовпця після знака = має бути таким самим, як і перед знаком. Збільшення/зменшення можливе лише для лічильників. Див. розділ про лічильники для деталей.
- `id = id + <some-collection>` і `id[value1] = value2` використовуються для колекцій. Див. розділ про колекції для деталей.
- `id.field = 3` використовується для встановлення значення поля в незаморожених користувацьких типах. Див. розділ про користувацькі типи (UDTs) для деталей.

### Параметри оновлення
Оператори `UPDATE` і `INSERT` підтримують такі параметри:
- `TTL`: визначає необов’язковий час життя (у секундах) для вставлених значень. Якщо задано, вставлені значення автоматично видаляються з бази даних після зазначеного часу. TTL стосується значень, а не стовпців. Це означає, що будь-яке наступне оновлення стовпця також скидає TTL (на той, що вказано в цьому оновленні). За замовчуванням значення не мають часу життя. TTL, рівний 0, еквівалентний його відсутності. Якщо таблиця має default_time_to_live, TTL = 0 видаляє TTL для вставлених чи оновлених значень. TTL, рівний null, також еквівалентний вставленню з TTL = 0.

Оператори `UPDATE`, `INSERT`, `DELETE` і `BATCH` підтримують такі параметри:
- `TIMESTAMP`: встановлює мітку часу для операції. Якщо не вказано, координатор використовує поточний час (у мікросекундах) на момент початку виконання оператора. Це зазвичай є підходящим значенням за замовчуванням.

## Видалення даних

Видалення рядків або частин рядків виконується за допомогою оператора `DELETE`:

```bnf
delete_statement::= DELETE [ simple_selection ( ',' simple_selection ) ]
	FROM table_name
	[ USING update_parameter ( AND update_parameter# )* ]
	WHERE where_clause
	[ IF ( EXISTS | condition ( AND condition)*) ]
```
#### Приклад:
```sql
DELETE FROM NerdMovies USING TIMESTAMP 1240003134
 WHERE movie = 'Serenity';

DELETE phone FROM Users
 WHERE userid IN (C73DE1D3-AF08-40F3-B124-3FF3E5109F22, B70DE1D0-9908-4AE3-BE34-5573E5B09F14);
```
Оператор `DELETE` дозволяє видаляти як цілі рядки, так і окремі стовпці. Якщо після ключового слова `DELETE` вказані назви стовпців, видаляються лише ці стовпці в рядках, зазначених у виразі `WHERE`. Якщо стовпці не вказані, видаляються цілі рядки.

Клаузула `WHERE` визначає, які рядки потрібно видалити. Можна видаляти декілька рядків за одну операцію, використовуючи оператор `IN`. Діапазон рядків можна вказати за допомогою операторів порівняння (наприклад, `>=`).

Параметр TIMESTAMP доступний в операторі `DELETE` і має таку саму семантику, як і в операторах оновлення (`UPDATE`).

Атомарність і ізоляція: Усі видалення в межах одного ключа розділу (`partition key`) виконуються атомарно та ізольовано.

Умовне видалення: Оператор `DELETE` може бути умовним завдяки використанню клаузули `IF`, подібно до операторів `UPDATE` та `INSERT`. Проте використання `IF` має значні витрати на продуктивність, оскільки застосовується протокол Paxos. Цей механізм слід використовувати обережно.

## Виконання кількох операцій
Оператор `BATCH` дозволяє виконувати кілька операцій `INSERT`, `UPDATE` і `DELETE` в одному запиті, об'єднуючи їх у групу:

```sql
batch_statement ::=     BEGIN [ UNLOGGED | COUNTER ] BATCH
                        [ USING update_parameter( AND update_parameter)* ]
                        modification_statement ( ';' modification_statement )*
                        APPLY BATCH
modification_statement ::= insert_statement | update_statement | delete_statement
```
#### Приклад:
```sql
BEGIN BATCH
   INSERT INTO users (userid, password, name) VALUES ('user2', 'ch@ngem3b', 'second user');
   UPDATE users SET password = 'ps22dhds' WHERE userid = 'user3';
   INSERT INTO users (userid, password) VALUES ('user4', 'ch@ngem3c');
   DELETE name FROM users WHERE userid = 'user1';
APPLY BATCH;
```
Оператор `BATCH` групує кілька модифікацій (вставки, оновлення та видалення) в одну операцію. Його переваги:
- Оптимізація мережевих запитів: Зменшує кількість запитів між клієнтом і сервером (а іноді й між координатором сервера та репліками) під час виконання кількох оновлень.
- Ізольованість операцій: Усі оновлення в межах одного ключа розділу (`partition key`) виконуються ізольовано.
- Логування: За замовчуванням усі операції в `BATCH` виконуються як логовані (`LOGGED`), щоб гарантувати завершення всіх змін або їхнє повне скасування.
Особливості:
- `BATCH` може містити лише оператори `UPDATE`, `INSERT` і `DELETE`. Інші оператори, як-от вкладені `BATCH`, заборонені.
- `BATCH` не є повним аналогом SQL-транзакцій.
- Якщо не вказано часовий штамп для кожної операції, усі операції отримують однаковий штамп часу (згенерований автоматично або заданий на рівні `BATCH`). Через механізм вирішення конфліктів у Cassandra порядок застосування операцій може відрізнятися від їхнього порядку в `BATCH`. Для визначеного порядку необхідно задавати штампи часу окремо для кожної операції.
- Якщо `LOGGED`-батч стосується одного ключа розділу, він буде автоматично перетворений на UNLOGGED для оптимізації.

### Типи батчів:
- `UNLOGGED` батчі:
За замовчуванням Cassandra використовує журнал батчу для гарантії завершення всіх операцій або їхнього скасування. Проте ізоляція гарантується лише для одного ключа розділу.
Для батчів, що охоплюють кілька розділів, логування може знизити продуктивність. Використовуйте опцію UNLOGGED, щоб пропустити журнал батчу. У разі помилки частина батчу може залишитися застосованою.
- `COUNTER` батчі:
Використовуйте опцію COUNTER для роботи з лічильниками. Лічильники в Cassandra не є ідемпотентними (результат залежить від кількості виконань).