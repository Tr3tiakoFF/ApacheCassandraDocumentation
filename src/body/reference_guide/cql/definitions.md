# Визначення

## Конвенції

Для полегшення специфікації синтаксису CQL у цьому документі будуть використовуватися наступні конвенції:

- Правила мови будуть подані у неформальному варіанті нотації BNF. Зокрема, квадратні дужки `[ item ]` позначають необов’язкові елементи, `*` і `+` використовуються для повторюваних елементів (де `+` означає принаймні один повтор).
- Для зручності граматика використовує наступну конвенцію: нетермінальні терміни будуть писатися малими літерами (та міститимуть посилання на їх визначення), тоді як термінальні ключові слова подаватимуться у верхньому регістрі (наприклад, "ALL CAPS"). Однак слід зазначити, що ключові слова є `ідентифікаторами`, а отже, вони нечутливі до регістру на практиці. Ми також визначимо деякі початкові конструкції за допомогою регулярних виразів, які будемо позначати як `re(<деякий регулярний вираз>)`.
- Граматика надається для довідкових цілей і може опускати деякі незначні деталі. Наприклад, у визначенні останнього стовпця у команді `CREATE TABLE` кома є необов’язковою, проте підтримується, навіть якщо граматика в цьому документі вказує протилежне. Крім того, не все, що дозволяє граматика, обов’язково є валідним кодом CQL.
- Посилання на ключові слова або частини коду CQL у тексті подаються у `шрифті з фіксованою шириною`.

## Ідентифікатори та ключові слова
Мова CQL використовує ідентифікатори (або імена) для позначення таблиць, стовпців та інших об’єктів. Ідентифікатор — це токен, що відповідає регулярному виразу `[a-zA-Z][a-zA-Z0-9_]*`.

Декілька таких ідентифікаторів, як-от `SELECT` або `WITH`, є ключовими словами. Вони мають фіксоване значення для мови, і більшість із них зарезервовані. Список цих ключових слів можна знайти в [Додатку А](/body/reference_guide/cql/appendices/appendix_a.md).

Ідентифікатори та (не в лапках) ключові слова нечутливі до регістру. Таким чином, `SELECT` є тим самим, що й `select` або `sElEcT`, а `myId` є тим самим, що й `myid` або `MYID`. Конвенція, яку часто використовують (зокрема, у прикладах цього документа), — це використовувати великі літери для ключових слів і малі для інших ідентифікаторів.

Існує другий тип ідентифікаторів, званих "цитованими ідентифікаторами", які визначаються шляхом обрамлення довільної послідовності символів (не порожньої) у подвійні лапки (`"`). Цитовані ідентифікатори ніколи не є ключовими словами. Отже, `"select"` не є зарезервованим ключовим словом і може використовуватися для позначення стовпця (хоча зазвичай це не рекомендується), тоді як `select` викличе помилку парсингу. Також, на відміну від нецитованих ідентифікаторів і ключових слів, цитовані ідентифікатори чутливі до регістру (`"My Quoted Id"` відрізняється від `"my quoted id"`). Повністю малий цитований ідентифікатор, що відповідає регулярному виразу `[a-zA-Z][a-zA-Z0-9_]*`, однак, еквівалентний нецитованому ідентифікатору, отриманому шляхом видалення подвійних лапок (тобто `"myid"` еквівалентний `myid` і `myId`, але відрізняється від `"myId"`). Всередині цитованого ідентифікатора можна подвійно повторювати символ подвійної лапки для екранування, наприклад, `"foo "" bar"` є валідним ідентифікатором.

*Цитовані ідентифікатори можуть оголошувати стовпці з довільними іменами, і ці імена можуть іноді конфліктувати з певними іменами, які використовуються сервером. Наприклад, при використанні умовного оновлення сервер може повернути набір результатів, що містить спеціальний результат з назвою `"[applied]"`. Якщо ви оголосили стовпець з таким ім'ям, це може заплутати деякі інструменти, і таких імен слід уникати. Загалом, рекомендується використовувати нецитовані ідентифікатори, але якщо ви використовуєте цитовані, настійно радимо уникати будь-якого імені, яке містить квадратні дужки (як-от `"[applied]"`), а також імен, що нагадують виклик функції (наприклад, `"f(x)"`).*

Більш формально:
```bnf
identifier::= unquoted_identifier | quoted_identifier
unquoted_identifier::= re('[a-zA-Z][link:[a-zA-Z0-9]]*')
quoted_identifier::= '"' (будь-який символ, де " може з'являтися, якщо подвоєний)+ '"'
```

## Константи
CQL визначає такі константи:

```bnf
constant::= string | integer | float | boolean | uuid | blob | NULL
string::= ''' (будь-який символ, де ' може з’являтися, якщо подвоєний)+ ''' : '$$' (будь-який символ, крім '$$') '$$'
integer::= re('-?[0-9]+')
float::= re('-?[0-9]+(.[0-9]*)?([eE][+-]?[0-9+])?') | NAN | INFINITY
boolean::= TRUE | FALSE
uuid::= hex\{8}-hex\{4}-hex\{4}-hex\{4}-hex\{12}
hex::= re("[0-9a-fA-F]")
blob::= '0' ('x' | 'X') hex+
```

Інакше кажучи:

- Строкова константа — це довільна послідовність символів, оточена одинарними лапками (`'`). Одинарну лапку можна включити, подвоївши її, наприклад: `'It''s raining today'`. Це не слід плутати з цитованими `ідентифікаторами`, що використовують подвійні лапки. Або ж строку можна визначити, оточивши її двома знаками долара (`$$`), тоді одинарну лапку можна використовувати без екранування (наприклад, `It's raining today`). Така форма часто використовується при визначенні функцій користувача, щоб уникнути необхідності екранувати одинарні лапки в тілі функції (оскільки вони можуть зустрічатися частіше за `$$`).
- Цілі числа, числа з плаваючою комою та булеві константи визначаються стандартним чином. Проте для числа з плаваючою комою дозволені спеціальні значення `NaN` (Not a Number) та `Infinity`.
- CQL підтримує константи UUID.
- Вміст для BLOB (Binary Large Object) надається в шістнадцятковому вигляді та префіксується `0x`.
- Спеціальна константа `NULL` позначає відсутність значення.

Для того, як ці константи типізуються, див. розділ про [Типи даних](/body/reference_guide/cql/data_types.md).

## Терміни

CQL має поняття терміну, який позначає типи значень, що підтримуються в CQL. Терміни визначаються так:

```bnf
term::= constant | literal | function_call | arithmetic_operation | type_hint | bind_marker
literal::= collection_literal | vector_literal | udt_literal | tuple_literal
function_call::= identifier '(' [ term (',' term)* ] ')'
arithmetic_operation::= '-' term | term ('+' | '-' | '*' | '/' | '%') term
type_hint::= '(' cql_type ')' term
bind_marker::= '?' | ':' identifier
```

Термін є одним із наступних:
- Константа
- Літерал колекції, вектора, типу, визначеного користувачем або кортежу
- Виклик функції, як вбудованої, так і користувацької
- Арифметична операція між термінами
- Підказка типу
- Маркер прив'язки, що позначає змінну, яка буде прив’язана під час виконання. Маркер прив’язки може бути анонімним (`?`) або іменованим (`:some_name`). Остання форма зручніша для звернення до змінної під час прив’язки і зазвичай є рекомендованою.

## Коментарі
Коментар у CQL починається з подвійних дефісів (`--`) або подвійного косого слэшу (`//`).

Також підтримуються багаторядкові коментарі, які огортаються в `/*` та `*/` (але вкладені коментарі не підтримуються).

```bnf
-- Це коментар
// Це теж коментар
/* Це
   багаторядковий коментар */
```

## Запити

CQL складається з запитів, які можна поділити на такі категорії:

- `data-definition`: Запити для визначення даних, що визначають і змінюють спосіб зберігання даних (простори ключів та таблиці).
- `data-manipulation`: Запити для маніпулювання даними, які використовуються для вибору, вставки та видалення даних.
- `secondary-indexes`: Запити для створення вторинних індексів.
- `materialized-views`: Запити для створення матеріалізованих уявлень.
- `cql-roles`: Запити для визначення ролей CQL.
- `cql-permissions`: Запити для налаштування дозволів CQL.
- `User-Defined Functions (UDFs)`: Запити для визначення функцій, створених користувачем (UDF).
- `udts`: Запити для створення типів, створених користувачем (UDT).
- `cql-triggers`: Запити для створення тригерів.

Всі запити наведені нижче і описані в іншій частині цього документа (див. посилання вище):

```bnf
cql_statement::= statement [ ';' ]
statement::= ddl_statement
           | dml_statement
           | secondary_index_statement
           | materialized_view_statement
           | role_or_permission_statement
           | udf_statement
           | udt_statement
           | trigger_statement
ddl_statement::= use_statement
              | create_keyspace_statement
              | alter_keyspace_statement
              | drop_keyspace_statement
              | create_table_statement
              | alter_table_statement
              | drop_table_statement
              | truncate_statement
dml_statement::= select_statement
              | insert_statement
              | update_statement
              | delete_statement
              | batch_statement
secondary_index_statement::= create_index_statement
                            | drop_index_statement
materialized_view_statement::= create_materialized_view_statement
                              | drop_materialized_view_statement
role_or_permission_statement::= create_role_statement
                               | alter_role_statement
                               | drop_role_statement
                               | grant_role_statement
                               | revoke_role_statement
                               | list_roles_statement
                               | grant_permission_statement
                               | revoke_permission_statement
                               | list_permissions_statement
                               | create_user_statement
                               | alter_user_statement
                               | drop_user_statement
                               | list_users_statement
udf_statement::= create_function_statement
              | drop_function_statement
              | create_aggregate_statement
              | drop_aggregate_statement
udt_statement::= create_type_statement
              | alter_type_statement
              | drop_type_statement
trigger_statement::= create_trigger_statement
                  | drop_trigger_statement
```

## Підготовлені запити
CQL підтримує підготовлені запити. Підготовлені запити — це оптимізація, яка дозволяє розпарсити запит лише один раз, але виконувати його кілька разів із різними конкретними значеннями.

Будь-який запит, який використовує хоча б один маркер прив'язки, повинен бути підготовлений. Після цього запит можна виконати, надаючи конкретні значення для кожного його маркера. Точні деталі того, як запит підготовлюється та виконується, залежать від використаного драйвера CQL, і вам слід звертатися до документації вашого драйвера для додаткової інформації.