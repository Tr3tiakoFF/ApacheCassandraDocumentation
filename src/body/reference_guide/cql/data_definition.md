# Визначення даних

CQL зберігає дані у таблицях, схема яких визначає структуру даних у таблиці. Таблиці розташовані в keyspaces. Keyspace визначає параметри, які застосовуються до всіх таблиць цього keyspace. Важливими параметрами keyspace є стратегія реплікації та фактор реплікації. Загальне правило: один keyspace на одну програму. У кластері зазвичай визначається лише один keyspace для активної програми.

У цьому розділі описані команди для створення, зміни та видалення keyspace і таблиць.

## Загальні визначення

Назви keyspace і таблиць визначаються наступною граматикою:

```bnf
keyspace_name ::= name
table_name ::= [keyspace_name '.' ] name
name ::= unquoted_name | quoted_name
unquoted_name ::= re('[a-zA-Z_0-9]{1,48}')
quoted_name ::= '"' unquoted_name '"'
```

Назви keyspace і таблиць повинні складатися тільки з алфавітно-цифрових символів, не можуть бути порожніми і обмежені до 48 символів. Це обмеження існує переважно для уникнення перевищення лімітів деяких файлових систем, оскільки імена keyspace і таблиць можуть бути частиною імен файлів. За замовчуванням, імена нечутливі до регістру (`myTable` еквівалентно `mytable`), але чутливість до регістру можна примусово встановити за допомогою подвійних лапок (`"myTable"` відрізняється від `mytable`).

Крім того, таблиця завжди є частиною keyspace, і її назву можна вказати у форматі повного імені (з префіксом keyspace). Якщо назва таблиці не вказана повністю, то вважається, що таблиця належить до поточного keyspace (див. команду USE).

Назви стовпців визначаються наступним чином:

```bnf
Copy code
column_name ::= identifier
```
Також визначається поняття опцій у командах:

```
options ::= option ( AND option )*
option ::= identifier '=' ( identifier
    | constant
    | map_literal )
```

## Створення кейспейсу

Keyspace створюється за допомогою команди `CREATE KEYSPACE`:

'''bnf
create_keyspace_statement ::= CREATE KEYSPACE [ IF NOT EXISTS ] keyspace_name WITH options
'''

### Приклад:

```sql
CREATE KEYSPACE excelsior
   WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 3};

CREATE KEYSPACE excalibur
   WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1': 1, 'DC2': 3}
   AND durable_writes = false;
```

*Якщо спробувати створити keyspace, який вже існує, це призведе до помилки, якщо не використано опцію IF NOT EXISTS. Якщо ця опція використана, команда не виконається, якщо keyspace вже існує.*

### Підтримувані опції:
| Назва              | Тип    | Обов'язково | За замовчуванням | Опис                                                                                   |
|--------------------|--------|-------------|------------------|----------------------------------------------------------------------------------------|
| `replication`      | map    | так         | n/a              | Стратегія реплікації та параметри для keyspace (див. деталі нижче).                    |
| `durable_writes`   | простий| ні          | true             | Чи використовувати журнал комітів для оновлень у цьому keyspace (відключення на ваш ризик!). |

Це обов’язкова властивість, яка повинна містити підопцію class, що визначає бажаний клас стратегії реплікації. Решта підопцій залежать від обраної стратегії реплікації. За замовчуванням, Cassandra підтримує наступні значення class:

### `SimpleStrategy`
Проста стратегія, яка визначає фактор реплікації для розподілу даних по всьому кластеру. Це зазвичай не рекомендується для продакшн-середовища, оскільки не враховує розташування дата-центрів і може призвести до значних затримок запитів. Для продакшн-середовища використовуйте NetworkTopologyStrategy.

#### Аргумент:
| Підопція              | Тип  | Опис                                      |
|-----------------------|------|-------------------------------------------|
| `replication_factor`  | int  | Кількість реплік для зберігання на діапазон |

### `NetworkTopologyStrategy`
Стратегія реплікації для продакшн-середовища, яка встановлює фактор реплікації незалежно для кожного дата-центру. Решта підопцій є парами "ключ-значення", де ключ — це назва дата-центру, а значення — відповідний фактор реплікації.

#### Параметри:
| Підопція              | Тип  | Опис                                                                            |
|-----------------------|------|----------------------------------------------------------------------------------|
| `<datacenter>`        | int  | Кількість реплік для зберігання на діапазон у зазначеному дата-центрі.          |
| `replication_factor`  | int  | При зміні replication_factor нові дата-центри додаються автоматично.            |


### Приклади автоматичного розширення дата-центрів:
- Автоматичне розширення двох дата-центрів DC1 та DC2:
```sql
CREATE KEYSPACE excalibur
    WITH replication = {'class': 'NetworkTopologyStrategy', 'replication_factor': 3};
```
```sql
DESCRIBE KEYSPACE excalibur;
```
Результат:
```sql
CREATE KEYSPACE excalibur WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1': '3', 'DC2': '3'} AND durable_writes = true;
```

- Зміна фактора реплікації для одного дата-центру:
```sql
CREATE KEYSPACE excalibur
    WITH replication = {'class': 'NetworkTopologyStrategy', 'replication_factor': 3, 'DC2': 2};
```
```sql
DESCRIBE KEYSPACE excalibur;
```
Результат:
```sql
CREATE KEYSPACE excalibur WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1': '3', 'DC2': '2'} AND durable_writes = true;
```

-Виключення дата-центру:
```sql
CREATE KEYSPACE excalibur
    WITH replication = {'class': 'NetworkTopologyStrategy', 'replication_factor': 3, 'DC2': 0};
```
```sql
DESCRIBE KEYSPACE excalibur;
```
Результат:
```sql
CREATE KEYSPACE excalibur WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1': '3'} AND durable_writes = true;
```

### Транзитна реплікація (Transient Replication)
Якщо ввімкнено транзитну реплікацію, можна налаштувати транзитні репліки для стратегій `SimpleStrategy` та `NetworkTopologyStrategy`, задавши фактори реплікації у форматі `<загальні_репліки>/<транзитні_репліки>`.

#### Приклад:
Keyspace із 3 репліками в DC1 (1 з яких транзитна) та 5 репліками в DC2 (2 з яких транзитні):
```sql
CREATE KEYSPACE some_keyspace
   WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1': '3/1', 'DC2': '5/2'};
```

## USE

Команда `USE` змінює поточний keyspace на зазначений. У CQL багато об'єктів (таблиці, користувацькі типи, функції тощо) прив'язані до keyspace. Поточний keyspace є keyspace за замовчуванням, який використовується, коли ці об'єкти згадуються у запиті без повного кваліфікованого імені (без префікса keyspace). Команда `USE` задає keyspace для використання:

```bnf
use_statement ::= USE keyspace_name
```

#### Приклад:
```sql
USE excelsior;
```

## Зміна існуючого кейспейсу
Команда ALTER KEYSPACE змінює параметри keyspace:

```bnf
alter_keyspace_statement ::= ALTER KEYSPACE [ IF EXISTS ] keyspace_name WITH options
```
#### Приклад:
```sql
ALTER KEYSPACE excelsior WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 4};
```
Якщо keyspace не існує, команда повертає помилку, якщо не використано опцію IF EXISTS. Якщо опція використана, команда не виконується.

Підтримувані параметри ті самі, що й при створенні keyspace.

## Видалення існуючого кейспейсу
Команда DROP KEYSPACE видаляє keyspace:
```bnf
drop_keyspace_statement ::= DROP KEYSPACE [ IF EXISTS ] keyspace_name
```
#### Приклад:
```sql
DROP KEYSPACE excelsior;
```
Видалення keyspace призводить до негайного та незворотного видалення keyspace, включаючи всі таблиці, користувацькі типи, функції та всі дані, що містяться в цих таблицях.

Якщо keyspace не існує, команда повертає помилку, якщо не використано опцію IF EXISTS. У цьому випадку команда не виконується.

## Створення нової таблиці

Створення нової таблиці виконується за допомогою команди `CREATE TABLE`:

```bnf
create_table_statement ::= CREATE TABLE [ IF NOT EXISTS ] table_name '(' column_definition ( ',' column_definition )* [ ',' PRIMARY KEY '(' primary_key ')' ] ')' [ WITH table_options ] column_definition ::= column_name cql_type [ STATIC ] [ column_mask ] [ PRIMARY KEY] column_mask ::= MASKED WITH ( DEFAULT | function_name '(' term ( ',' term )* ')' ) primary_key ::= partition_key [ ',' clustering_columns ] partition_key ::= column_name | '(' column_name ( ',' column_name )* ')' clustering_columns ::= column_name ( ',' column_name )* table_options ::= COMPACT STORAGE [ AND table_options ] | CLUSTERING ORDER BY '(' clustering_order ')' [ AND table_options ] | options clustering_order ::= column_name (ASC | DESC) ( ',' column_name (ASC | DESC) )*
```

#### Приклади:

CQL-таблиця має назву та складається з набору рядків. Створення таблиці передбачає визначення стовпців, які матимуть рядки, визначення первинного ключа та встановлення параметрів таблиці.

```sql
CREATE TABLE monkey_species (
    species text PRIMARY KEY,
    common_name text,
    population varint,
    average_size int
) WITH comment='Important biological records';

CREATE TABLE timeline (
    userid uuid,
    posted_month int,
    posted_time uuid,
    body text,
    posted_by text,
    PRIMARY KEY (userid, posted_month, posted_time)
) WITH compaction = { 'class' : 'LeveledCompactionStrategy' };

CREATE TABLE loads (
    machine inet,
    cpu int,
    mtime timeuuid,
    load float,
    PRIMARY KEY ((machine, cpu), mtime)
) WITH CLUSTERING ORDER BY (mtime DESC);
```

Спроба створити таблицю, яка вже існує, повертає помилку, якщо не використано опцію IF NOT EXISTS. У такому разі команда не виконується.

### Опис стовпців
Кожен рядок у таблиці CQL матиме заздалегідь визначені стовпці, що були задані під час створення таблиці. Стовпці можна додавати пізніше за допомогою команди `ALTER`.

- `STATIC`: оголошує стовпець статичним.
- `PRIMARY KEY`: оголошує стовпець як єдиний компонент первинного ключа таблиці.

#### Статичні стовпці
Деякі стовпці можна оголосити статичними (STATIC) у визначенні таблиці. Статичний стовпець буде “спільним” для всіх рядків у тому ж розділі (з однаковим ключем розділу).

#### Приклад:
```sql
CREATE TABLE t (
    pk int,
    t int,
    v text,
    s text static,
    PRIMARY KEY (pk, t)
);
INSERT INTO t (pk, t, v, s) VALUES (0, 0, 'val0', 'static0');
INSERT INTO t (pk, t, v, s) VALUES (0, 1, 'val1', 'static1');
SELECT * FROM t;
```
#### Результат:
```
 pk | t | v    | s
----+---+------+---------
  0 | 0 | val0 | static1
  0 | 1 | val1 | static1
```

#### Обмеження:
- Таблиця без кластерних стовпців не може мати статичних стовпців.
- Тільки стовпці, які не є частиною первинного ключа, можуть бути статичними.

### Первинний ключ

У кожній таблиці рядок унікально ідентифікується первинним ключем (`PRIMARY KEY`), який повинен бути визначений для кожної таблиці.

#### Структура:
- Ключ розділу (`Partition Key`): перший компонент первинного ключа.
- Кластерні стовпці (`Clustering Columns`): визначають порядок кластеризації рядків у розділі.

##### Приклади:
- `PRIMARY KEY (a)`: a — ключ розділу, кластерні стовпці відсутні.
- `PRIMARY KEY (a, b, c)`: a — ключ розділу, b та c — кластерні стовпці.
- `PRIMARY KEY ((a, b), c)`: a і b — складений ключ розділу, c — кластерний стовпець.

#### Ключ розділу (Partition Key)

Це перший компонент `PRIMARY KEY`.

Може бути одним стовпцем або кількома стовпцями (у дужках).
Визначає, як дані розподіляються у кластері.

##### Приклад:
```sql
CREATE TABLE t (
    a int,
    b int,
    c int,
    d int,
    PRIMARY KEY ((a, b), c, d)
);
```
##### Дані:
```sql
INSERT INTO t (a, b, c, d) VALUES (0, 0, 0, 0);
INSERT INTO t (a, b, c, d) VALUES (0, 0, 1, 1);
INSERT INTO t (a, b, c, d) VALUES (0, 1, 2, 2);
INSERT INTO t (a, b, c, d) VALUES (0, 1, 3, 3);
INSERT INTO t (a, b, c, d) VALUES (1, 1, 4, 4);
```

##### Результат:

```
 a | b | c | d
---+---+---+---
 0 | 0 | 0 | 0
 0 | 0 | 1 | 1
 0 | 1 | 2 | 2
 0 | 1 | 3 | 3
 1 | 1 | 4 | 4
```

#### Кластерні стовпці (Clustering Columns)

Це стовпці, які йдуть після ключа розділу у визначенні `PRIMARY KEY`.
Визначають порядок кластеризації рядків у межах одного розділу.
Додають унікальність для рядка.
##### Приклад:
```sql
CREATE TABLE t2 (
    a int,
    b int,
    c int,
    d int,
    PRIMARY KEY (a, b, c)
);
```
##### Дані:
```sql
INSERT INTO t2 (a, b, c, d) VALUES (0, 0, 0, 0);
INSERT INTO t2 (a, b, c, d) VALUES (0, 0, 1, 1);
INSERT INTO t2 (a, b, c, d) VALUES (0, 1, 2, 2);
INSERT INTO t2 (a, b, c, d) VALUES (0, 1, 3, 3);
INSERT INTO t2 (a, b, c, d) VALUES (1, 1, 4, 4);
```

##### Результат:

```
 a | b | c | d
---+---+---+---
 1 | 1 | 4 | 4
 0 | 0 | 0 | 0
 0 | 0 | 1 | 1
 0 | 1 | 2 | 2
 0 | 1 | 3 | 3
 ```

#### Унікальність Primary Key
`PRIMARY KEY` унікально ідентифікує рядок у таблиці. Якщо вставити рядок із тим самим `PRIMARY KEY`, відбудеться UPSERT — існуючий рядок буде замінено.

#### Моделювання даних із використанням Primary Key

- Ключ розділу гарантує, що всі рядки одного розділу зберігаються на одних і тих самих вузлах репліки.
- Кластерні стовпці визначають порядок зберігання рядків у розділі.
- Оптимальне моделювання Primary Key забезпечує мінімальну затримку під час отримання даних.

#### Ефективне використання Primary Key

Використовуйте ключі розділу, які рівномірно розподіляють дані по кластеру.
Уникайте створення надто великих або надто маленьких розділів, оскільки це може призвести до "гарячих точок" (hotspots) при читанні або записі.
Плануйте моделювання даних, виходячи з типових запитів до таблиці.

```sql
SELECT * FROM t2 WHERE a = 0 AND b > 0 AND b <= 3;
```
##### Результат:
```
 a | b | c | d
---+---+---+---
 0 | 1 | 2 | 2
 0 | 1 | 3 | 3
```

### Опції таблиці

У таблиці CQL є низка опцій, які можна задати під час створення (і більшість з них змінити пізніше). Ці опції задаються після ключового слова `WITH`.

Однією з важливих опцій, яку не можна змінити після створення, є `CLUSTERING ORDER BY`. Вона впливає на те, як виконуються запити до таблиці, і заслуговує детального розгляду.

#### Порядок кластеризації
Порядок кластеризації таблиці визначається стовпцями кластеризації. За замовчуванням порядок кластеризації є зростаючим для типів даних кластеризаційних стовпців. Наприклад, цілі числа впорядковуються як 1, 2, … n, тоді як текст впорядковується від A до Z.

Опція `CLUSTERING ORDER BY` використовує список кластеризаційних стовпців, розділений комами, для кожного з яких встановлюється порядок `ASC` (зростаючий) або `DESC` (спадний). Якщо опцію `CLUSTERING ORDER BY` не вказано, за замовчуванням застосовується зростаючий порядок для всіх кластеризаційних стовпців.

Ця опція фактично є підказкою для механізму зберігання, яка змінює порядок, у якому рядки зберігаються. Однак варто враховувати її наслідки:

Вона змінює порядок результатів за замовчуванням при виконанні запиту `SELECT` без оператора `ORDER BY`.

Вона обмежує використання оператора `ORDER BY` у запитах `SELECT` для цієї таблиці. Результати можуть бути впорядковані лише в початковому порядку кластеризації або у зворотному. Наприклад, якщо таблиця створена зі стовпцями кластеризації a і b, визначеними як `WITH` `CLUSTERING` `ORDER BY` `(a DESC, b ASC)`, то запити можуть використовувати `ORDER BY` `(a DESC, b ASC)` або `ORDER BY` `(a ASC, b DESC)`. Змішаний порядок, наприклад `ORDER BY` `(a ASC, b ASC)` або `ORDER BY` `(a DESC, b DESC)`, не забезпечить очікуваного порядку.

Це впливає на продуктивність запитів. Запити у зворотному порядку кластеризації виконуються повільніше, ніж у порядку за замовчуванням (зростаючому). Якщо плануєте виконувати більшість запитів у спадному порядку, вкажіть це в схемі таблиці за допомогою `WITH` `CLUSTERING` `ORDER BY` (). Така оптимізація є поширеною для часових рядів, коли дані потрібно отримувати від найновіших до найстаріших.

#### Інші опції таблиці
Таблиці підтримують такі опції:
| Опція                  | Тип      | За замовчуванням | Опис|
|----------------------------|--------------|-----------------------|----------------------|
| `comment`                 | simple       | none                 | Людське зрозуміле коментарне поле в довільному форматі                                                         |
| `speculative_retry`       | simple       | 99PERCENTILE         | Опції спекулятивного повторного запиту                                                                         |
| `cdc`                     | boolean      | false                | Увімкнення журналу Change Data Capture (CDC)                                                                  |
| `additional_write_policy` | simple       | 99PERCENTILE         | Аналогічно `speculative_retry`                                                                                |
| `gc_grace_seconds`        | simple       | 864000               | Час очікування перед очищенням позначок видалення (tombstones)                                                 |
| `bloom_filter_fp_chance`  | simple       | 0.00075              | Ймовірність хибнопозитивних спрацювань фільтрів Блума для sstable                                              |
| `default_time_to_live`    | simple       | 0                    | Стандартний час життя ("TTL") записів у таблиці в секундах                                                     |
| `compaction`              | map          | див. нижче          | Опції компакції                                                                                               |
| `compression`             | map          | див. нижче          | Опції стиснення                                                                                               |
| `caching`                 | map          | див. нижче          | Опції кешування                                                                                               |
| `memtable_flush_period_in_ms` | simple   | 0                    | Час (у мс) перед тим, як Cassandra очищає memtables на диск                                                   |
| `read_repair`             | simple       | BLOCKING             | Поведінка read-repair (див. нижче)                                                                            |

#### Опції спекулятивного повторного запиту
За замовчуванням координатори Cassandra читають дані лише з тієї кількості реплік, яка потрібна для забезпечення рівня узгодженості: одна репліка для рівня `ONE`, кворум для рівня `QUORUM` тощо. Опція `speculative_retry` визначає, коли координатор може запитати додаткові репліки, що корисно в разі повільної або неробочої репліки. Це дозволяє зменшити затримки.

*Читання з додаткових реплік надто часто може погіршити продуктивність кластера. Якщо не впевнені, використовуйте значення за замовчуванням — `99PERCENTILE`.*

До Cassandra 4.0 політика `speculative_retry` приймає єдиний рядок як параметр:
- `NONE`
- `ALWAYS`
- `99PERCENTILE` (або будь-який відсоток)
- `50MS` (кастомне значення)

##### Приклади:

- Задаємо кастомне значення:
```sql
ALTER TABLE users WITH speculative_retry = '10ms';
```
Задаємо відсотковий показник:
```sql
ALTER TABLE users WITH speculative_retry = '99PERCENTILE';
```

*Якщо один із вузлів стає недоступним, це може вплинути на перцентилі, і значення `p99` може не працювати як очікувалося.*


*При рівні узгодженості `ALL` всі репліки запитуються незалежно від `speculative_retry`.*

#### Спекулятивний повтор у Cassandra 4.0
Cassandra 4.0 підтримує нечутливість до регістру значень `speculative_retry` (наприклад, `none`, `None`, `NONE` працюють однаково). Також додаються нові значення:

| Формат                | Приклад            | Опис                                                                                 |
|---------------------------|------------------------|-----------------------------------------------------------------------------------------|
| `NONE`                   |                        | Спекулятивні запити вимкнено                                                              |
| `ALWAYS`                 |                        | Спекулятивні запити виконуються завжди                                                    |
| `99PERCENTILE`           | `99PERCENTILE`        | Виконання спекулятивного запиту для значень, що перевищують 99-й перцентиль часу відповіді. |
| `50MS`                   | `50ms`                | Спекулятивний запит, якщо репліка відповідає довше 50 мс                                  |
| `XPERCENTILE`            | `90.5PERCENTILE`      | Додатковий запит, якщо час відповіді перевищує X% середнього. X: 0–100.                  |
| `XP`                     | `90.5P`               | Те саме, що й `XPERCENTILE`.                                                             |
| `Yms`                    | `25ms`                | Додатковий запит, якщо час відповіді перевищує Y мілісекунд.                             |
| `MIN(XPERCENTILE,YMS)`   | `MIN(99PERCENTILE,35ms)` | Гібридна політика: використовується менше значення.                                      |
| `MAX(XPERCENTILE,YMS)`   | `MAX(90.5P,25ms)`     | Гібридна політика: використовується більше значення.                                     |

Ці політики дозволяють налаштовувати оптимальну поведінку для захисту від повільних або неробочих реплік.

Cassandra 4.0 підтримує гібридні політики `MIN()` і `MAX()` для спекулятивного повторного запиту, які дозволяють комбінувати значення: `MIN()`, `MAX()`, або їх комбінації. Гібридний режим буде використовувати мінімальне значення, якщо `p99` для таблиці < 50ms. Але якщо рівень `p99` перевищує максимальне значення, то використовується максимальне.

У гібридному значенні одне значення має бути фіксованим часом у мілісекундах, а інше — перцентилем. Наприклад:

- `min(99percentile,50ms)`
- `max(99p,50MS)`
- `MAX(99P,50ms)`
- `MIN(99.9PERCENTILE,50ms)`
- `max(90percentile,100MS)`
- `MAX(100.0PERCENTILE,60ms)`

#### Опції компакції

Мінімально потрібно визначити підопцію `class`, яка вказує стратегію компакції. Підтримуються такі класи:

- `SizeTieredCompactionStrategy` (STCS, за замовчуванням)
- `LeveledCompactionStrategy` (LCS)
- `TimeWindowCompactionStrategy` (TWCS)

Для користувацьких стратегій вкажіть повне ім’я класу як рядок.

Деталі параметрів кожної стратегії наведено у відповідних розділах: STCS, LCS, TWCS.

#### Опції стиснення

Опції стиснення задають, чи будуть SSTable таблиці стиснуті і як саме. Конфігурація виконується для кожної таблиці окремо. Параметри:

| Опція             | За замовчуванням | Опис                          |
|-----------------------|----------------------|--------------------------------------------------------------|
| `class`              | `LZ4Compressor`     | Алгоритм стиснення. Доступні: `LZ4Compressor`, `SnappyCompressor`, `DeflateCompressor`, `ZstdCompressor`. Використовуйте `'enabled': false` для відключення. |
| `enabled`            | `true`              | Увімкнення/вимкнення стиснення SSTable. Якщо встановлено `false`, інші опції не потрібно вказувати.                                                   |
| `chunk_length_in_kb` | `64`                | Розмір блоку (у KB) для стиснення SSTable.                                                                                                           |
| `compression_level`  | `3`                 | Рівень стиснення для `ZstdCompressor`. Приймає значення від -131072 до 22.                                                                            |

Приклад:
```sql
CREATE TABLE simple (
   id int,
   key text,
   value text,
   PRIMARY KEY (key, value)
) WITH compression = {'class': 'LZ4Compressor', 'chunk_length_in_kb': 4};
```

#### Опції кешування

Кешування оптимізує використання пам’яті таблиці. Параметри:
Приклад:
| Опція |	За замовчуванням |	Опис |
|------|-------------------|------------|
| `keys`	| `ALL`	| Чи кешувати ключі (key cache). Доступні значення: `ALL`, `NONE`. |
| `rows_per_partition` |	`NONE`	| Кількість рядків для кешування у кожному розділі (row cache). Можливі значення: `ALL`, `NONE`, або число. |

```sql
CREATE TABLE simple (
   id int,
   key text,
   value text,
   PRIMARY KEY (key, value)
) WITH caching = {'keys': 'ALL', 'rows_per_partition': 10};
```

#### Опції read repair
Опції read_repair налаштовують поведінку read repair:

|Опція |	За замовчуванням |	Опис |
|------|--------------------|--------|
|`BLOCKING` |	yes |	Під час read repair запит блокує записи на інші репліки до досягнення рівня узгодженості. |
|`NONE` |	no |	Координатор порівнює дані реплік, але не виправляє розбіжності. |

#### Застереження
- Монотонність читання: `BLOCKING` забезпечує монотонне читання при кворумі, запобігаючи поверненню даних, які могли зникнути.
- Атомарність запису: `NONE` забезпечує атомарність запису, але може порушити її, якщо читання виконується більш дрібно, ніж запис.

#### Додаткові рекомендації
Додавання нових стовпців через `ALTER TABLE` — це операція з постійним часом, тому не потрібно враховувати майбутні вимоги при створенні таблиці.

## Зміна існуючої таблиці

Зміна існуючої таблиці виконується за допомогою команди `ALTER TABLE`:

```bnf
alter_table_statement ::= ALTER TABLE [ IF EXISTS ] table_name alter_table_instruction alter_table_instruction ::= ADD [ IF NOT EXISTS ] column_definition ( ',' column_definition )* | DROP [ IF EXISTS ] column_name ( ',' column_name )* | RENAME [ IF EXISTS ] column_name TO column_name (AND column_name TO column_name )* | ALTER [ IF EXISTS ] column_name ( column_mask | DROP MASKED ) | WITH options column_definition ::= column_name cql_type [ column_mask ] column_mask ::= MASKED WITH ( DEFAULT | function_name '(' term ( ',' term )* ')' )
```

Якщо таблиця не існує, команда повертає помилку, якщо не використано опцію `IF EXISTS`. У цьому випадку команда не виконається.

#### Приклади:
```sql
ALTER TABLE addamsFamily ADD gravesite varchar;

ALTER TABLE addamsFamily
   WITH comment = 'A most excellent and useful table';
```
### Можливості команди ALTER TABLE:
- Додавання нового стовпця:
Новий стовпець не може бути частиною первинного ключа, оскільки первинний ключ таблиці не може бути змінений.
Додавання стовпця — це операція з постійним часом, що не залежить від кількості даних у таблиці.
Якщо стовпець уже існує, команда повертає помилку, якщо не використано опцію IF NOT EXISTS.
```sql
ALTER TABLE myTable ADD new_column int;
```
- Видалення стовпця:
Видаляє стовпець разом із його вмістом. Стовпець стає недоступним відразу, але його вміст видаляється поступово під час компакції.
Колонку можна повторно додати з тим самим ім'ям, якщо це не був незаморожений тип, наприклад, колекція.
```sql
ALTER TABLE myTable DROP old_column;
```
*Увага: Видалення стовпця передбачає використання "реальних" міток часу (у мікросекундах). Якщо ви використовуєте іншу схему міток часу, видалення може виконатися некоректно.*
- Перейменування стовпця:
Можна перейменувати лише стовпець первинного ключа.
Перейменування в ім'я, яке вже існує, не дозволяється.
Перейменовані стовпці не повинні мати залежних вторинних індексів.
```sql
ALTER TABLE myTable RENAME old_column TO new_column;
```
- Зміна параметрів таблиці:
Опції, які можна змінити, аналогічні тим, що використовуються під час створення таблиці, за винятком CLUSTERING ORDER.
```sql
ALTER TABLE myTable WITH compression = {'class': 'LZ4Compressor'};
```

## Видалення існуючої таблиці
Видалення таблиці виконується за допомогою команди `DROP TABLE`:

```bnf
drop_table_statement ::= DROP TABLE [ IF EXISTS ] table_name
```

#### Приклад:
```sql
DROP TABLE myTable;
```
Видалення таблиці призводить до негайного та незворотного видалення таблиці разом з усіма даними, що вона містить.

Якщо таблиця не існує, команда повертає помилку, якщо не використано опцію IF EXISTS.

## Очищення існуючої таблиці
Таблиця може бути очищена за допомогою команди `TRUNCATE`:
```bnf
truncate_statement ::= TRUNCATE [ TABLE ] table_name
```
Приклад:
```sql
TRUNCATE TABLE myTable;
```
Очищення таблиці видаляє всі існуючі дані з таблиці, але не видаляє саму таблицю.