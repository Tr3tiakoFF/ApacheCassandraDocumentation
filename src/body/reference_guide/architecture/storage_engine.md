# Движок зберігання

У Cassandra обробка даних при записі проходить через кілька етапів, починаючи з моменту запису в commit log і закінчуючи збереженням даних на диск у вигляді SSTables. Ось короткий опис кожного з цих етапів:

- Запис у журнал фіксації (Commit Log)
При кожній операції запису дані спочатку записуються в журнал фіксації (commit log), який зберігається на диску. Це забезпечує стійкість даних до збоїв: у разі відключення або збою система може відновити останні операції запису, використовуючи commit log.
- Запис даних у memtable
Після того як запис потрапив до commit log, дані зберігаються в пам'яті у структурі, яка називається memtable. Memtable — це структурована таблиця у пам’яті, яка тимчасово зберігає нові записи для швидкого доступу та подальшого скидання на диск.
- Скидання даних із memtable (Flushing)
Коли memtable досягає встановленого розміру або проходить певний інтервал часу, Cassandra «скидає» (flush) її на диск. Під час цього процесу дані з memtable записуються на диск у вигляді нової SSTable, яка є постійною структурою зберігання.
- Зберігання даних на диску у вигляді SSTables
Після скидання memtable на диск дані зберігаються у вигляді SSTables (Sorted String Tables) — незмінних, відсортованих таблиць, оптимізованих для швидкого читання. SSTables зберігають дані в упорядкованому вигляді та не змінюються після створення, що дозволяє забезпечити високу продуктивність при читанні та уникнути блокувань.

Ці етапи забезпечують баланс між швидким доступом до даних і надійністю зберігання, що дозволяє Cassandra ефективно обробляти записи в розподілених середовищах із високим навантаженням.

## Логування записів у commit log

Логування записів у commit log в Cassandra забезпечує надійність зберігання даних навіть у випадках неочікуваного вимкнення. При кожному записі дані додаються до локального файлу commit log, який служить для постійного журналювання всіх операцій запису на вузлі Cassandra, [надаючи можливість налаштовувати рівень надійності](/body/reference_guide/managing/casandra_yaml.html) шляхом фіксації кожного запису, зробленого на вузлі Cassandra. У разі перезавантаження система використовує commit log для відновлення даних, записаних перед збоєм, застосовуючи їх до memtable при запуску. Ось детальний опис параметрів та процесів, пов’язаних з commit log у Cassandra:

- commit log сегменти
Дані записуються в сегменти commit log, оптимізовані для запису з мінімальною кількістю операцій пошуку. Обмеження розміру сегментів задається параметром `commitlog_segment_size`, за замовчуванням — 32 МіБ. Коли сегмент досягає цього розміру, створюється новий сегмент. Після того, як всі дані з commit log переносяться до SSTables, сегменти commit log можуть бути видалені або перезаписані.

- Режими синхронізації commit log (`commitlog_sync`)

    - `batch` — Підтвердження запису відбувається тільки після синхронізації commit log із диском.
    - `periodic` — Записи підтверджуються відразу, а commit log синхронізується кожні
        - `commitlog_sync_period` мілісекунд (за замовчуванням 10000 мс).
        У випадку аварійного вимкнення в режимі `periodic`, Cassandra може втратити дані, створені впродовж періоду синхронізації.

- Розташування commit log (`commitlog_directory`)
За замовчуванням цей параметр не встановлений і директорія зберігання commit log визначена як `$CASSANDRA_HOME/data/commitlog`. Для зберігання журналу на магнітних жорстких дисках рекомендується використовувати окремий носій для оптимізації продуктивності.

- Компресія commit log (`commitlog_compression`)
Цей параметр дозволяє зберігати commit log у стислому вигляді з використанням таких алгоритмів, як LZ4, Snappy, Deflate або Zstd. Компресія за замовчуванням не використовується, але за бажанням можна включити відповідний метод.

- Обсяг commit log (`commitlog_total_space`)
Визначає максимальний обсяг простору на диску, виділеного для commit log. Якщо commit log перевищує цей ліміт, Cassandra автоматично «зливає» дані найстарішого сегмента до SSTables, що сприяє видаленню менш активних таблиць. За замовчуванням значення дорівнює 8192 МіБ або чверть загального доступного об’єму для commit log, залежно від того, що менше.  

Cassandra забезпечує можливість архівування, видалення або повторного використання сегментів commit log, а також автоматично проводить всі необхідні оптимізації для збільшення надійності та продуктивності роботи.

## Memtables

Коли виконується запис, Cassandra також записує дані в memtable. Memtable — це структура в пам'яті, де Cassandra буферизує записи. Зазвичай для кожної таблиці існує один активний memtable. Memtable є кешем зворотного запису розділів даних, які Cassandra шукає за ключем. Memtable може зберігатися повністю в оперативній пам'яті або частково поза нею, залежно від параметра `memtable_allocation_type`.

Memtable зберігає записи у впорядкованому вигляді до досягнення заданого обмеження. Коли це обмеження досягнуто, memtable скидається на диск та стає незмінним SSTable. Скидання може бути ініційовано кількома способами:

- Використання пам'яті memtable перевищує налаштований поріг (див. `memtable_cleanup_threshold`).
- `Commit log` наближається до свого максимального розміру та змушує виконати скидання memtable, щоб дозволити звільнити сегменти commit log.
Коли відбувається подія, що запускає скидання, memtable потрапляє в чергу для скидання на диск. Під час скидання дані записуються на диск у впорядкованому вигляді, як у memtable. Також на диску створюється індекс розділів, що співвідносить токени з їх розташуванням на диску.

Чергу можна налаштувати за допомогою параметрів `memtable_heap_space` або `memtable_offheap_space` у файлі `cassandra.yaml`. Якщо обсяг даних для скидання перевищує `memtable_cleanup_threshold`, Cassandra блокує записи, доки наступне скидання не буде успішним. Ви можете вручну скинути таблицю за допомогою `nodetool flush` або `nodetool drain` (скидає memtable без очікування підключень до інших вузлів). Щоб зменшити час відновлення commit log, рекомендується скинути memtable перед перезапуском вузлів. Якщо вузол перестає працювати, commit log відтворює записи в memtable, які були там до зупинки.

Дані у commit log видаляються після того, як відповідні дані в memtable скидаються в SSTable на диск.

## SSTables

SSTables — це незмінні файли даних, які Cassandra використовує для зберігання даних на диску. SSTables підтримуються окремо для кожної таблиці. Вони є незмінними та ніколи не перезаписуються після скидання memtable. Отже, розділ даних зазвичай зберігається в кількох файлах SSTable, оскільки дані додаються або змінюються.

Кожен SSTable складається з кількох компонентів, що зберігаються в окремих файлах:

- `Data.db`:
Фактичні дані, тобто вміст рядків.

- `Partitions.db`:
Файл індексу розділів співвідносить унікальні префікси розширених ключів розділів із розташуванням файлів даних або, у випадку широких розділів, індексованих у файлі індексу рядків, з місцями у файлі індексу рядків.

- `Rows.db`:
Файл індексу рядків містить записи лише для розділів, які мають більше одного рядка та перевищують один блок індексу. Для таких розділів він зберігає копію ключа розділу, заголовок розділу та індекс роздільників блоків рядків, які співвідносять кожен ключ рядка з першим блоком, де можна знайти рядок із таким або вищим ключем.

- `Index.db`:
Індекс від ключів розділів до позицій у файлі Data.db. Для широких розділів він також може включати індекс рядків у межах розділу.

- `Summary.db`:
Вибірка (за замовчуванням) кожного 128-го запису у файлі Index.db.

- `Filter.db`:
Фільтр Блума для ключів розділів у SSTable.

- `CompressionInfo.db`:
Метадані про зміщення та довжину блоків стиснення у файлі Data.db.

- `Statistics.db`:
Містить метадані про SSTable, включаючи інформацію про часові мітки, tombstones, ключі кластеризації, компактування, відновлення, стиснення, TTL тощо.

- `Digest.crc32`:
Контрольна сума CRC-32 файлу Data.db.

- `TOC.txt`:
Текстовий файл зі списком компонентних файлів для SSTable.

- `SAI.db*`:
Індексна інформація для індексів, підключених до сховища (Storage-Attached Indexes). Присутня лише тоді, коли SAI увімкнено для таблиці.

*Зауважте, що тип файлу `Index.db` було замінено файлами `Partitions.db` та `Rows.db`. Ця зміна є наслідком впровадження індексів Big Trie у Cassandra (CEP-25).*

У файлі `Data.db` рядки організовано за розділами. Ці розділи відсортовано за порядком токенів (тобто за хешем ключа розділу, якщо використовується стандартний партиціонер `Murmur3Partition`). У межах розділу рядки зберігаються в порядку їхніх ключів кластеризації.

SSTables можуть бути стиснуті блоковим стисненням за бажанням.

Коли SSTables скидаються на диск із `memtable` або надходять від інших вузлів, Cassandra запускає процес компактування, який об’єднує кілька SSTables в один. Після запису нового SSTable старі SSTables можуть бути видалені.


## Версії SSTable у Cassandra

Формат SSTable оновлюється з кожною новою версією Cassandra, додаючи нові функції, покращення продуктивності, індексацію та вдосконалення стиснення. Нижче наведено короткий огляд основних змін у кожній версії SSTable:

### Версія 0
- b (0.7.0): додано версію до імен файлів SSTable.
- c (0.7.0): фільтр Блума обчислює хеші за сирими байтами ключа.
- d (0.7.0): розмір рядка у компоненті даних стає long замість int.
- e (0.7.0): зберігає недекоровані ключі у компонентах даних та індексів.
- f (0.7.0): змінено реалізацію фільтра Блума у компоненті даних.
- g (0.8): відстежує контекст flushed-at у компоненті метаданих.
### Версія 1
- h (1.0): відстежує максимальний клієнтський timestamp у компоненті метаданих.
- hb (1.0.3): записує коефіцієнт стиснення у метадані.
- hc (1.0.4): зберігає partitioner у метадані.
- hd (1.0.10): включає tombstones для рядків у max timestamp.
- he (1.1.3): включає покоління предків у метадані.
- hf (1.1.6): маркер, що позиція відтворення відповідає id, заснованому на мілісекундах (CASSANDRA-4782).
### Версія 2
- ja (2.0.0):
серіалізує суперколонки як композити.
відстежує max local deletion time у метадані SSTable.
зберігає bloom_filter_fp_chance у метадані.
- jb (2.0.1): замінює crc32 на adler32 для перевірки стиснених даних.
- ka (2.1.0): новий формат файлу Statistics.db та можливість пониженої вибірки індексних зведень.
- la (2.2.0): новий формат імен файлів.
### Версія 3
- ma (3.0.0): зберігає рядки у нативному форматі.
- mc (3.0.8, 3.9): додано інтервали commit log.
- me (3.0.25, 3.11.11): додано hostId вузла, з якого походить SSTable.
### Версія 4
- na (4.0-rc1): незжаті блоки, новий формат фільтра Блума, файл метаданих із контрольними сумами.
- nb (4.0.0): host id вузла-відправника.
### Версія 5
- oa (5.0): покращено min/max, позначка наявності видалень на рівні розділу, покриття токенового простору для уникнення переповнення TTL

## Формати SSTable з індексацією Trie (BTI)
У Cassandra 5.0 з'явився новий формат SSTable із використанням Trie-індексації, відомий як BTI (Big Trie Index). Цей формат покращує продуктивність при роботі з великими наборами даних, завдяки ефективнішому індексуванню.

### Як увімкнути формат BTI
Щоб використовувати формат BTI, необхідно налаштувати cassandra.yaml, вказавши бажаний формат SSTable:

```yaml
sstable:
  selected_format: bti
```

Цей формат дозволяє Cassandra оптимізувати процеси читання та запису, особливо в сценаріях із високим навантаженням та великими розділами даних.

### Версія 5
- da (5.0) — початкова версія формату BTI (Big Trie Index), представлена у Cassandra 5.0. Цей формат був створений для ефективнішого індексування та роботи з даними у великих обсягах.

Приклад коду
Нижче наведено приклад коду для пошуку всіх SSTable, які не відповідають версії ib:

```bash
find /var/lib/cassandra/data/ -type f | grep -v -- -ib- | grep -v "/snapshots"
```
У цьому прикладі:

- `find /var/lib/cassandra/data/ -type f` — команда для пошуку всіх файлів у каталозі data.
- `grep -v -- -ib-` — відфільтровує файли, що містять -ib- у назві (версія ib).
- `grep -v "/snapshots"` — виключає файли в каталозі snapshots.

Цей код допоможе знайти всі SSTable, окрім тих, що мають версію ib, що може бути корисним для аналізу або обслуговування даних.