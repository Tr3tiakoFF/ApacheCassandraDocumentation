# Логічне моделювання даних

Тепер, коли запити визначено, можна починати проєктувати таблиці в Cassandra. Спочатку слід створити логічну модель, що містить таблицю для кожного запиту, і відобразити в ній сутності та зв’язки з концептуальної моделі.

Щоб назвати кожну таблицю, спочатку потрібно визначити основний тип сутності, за якою буде здійснюватися запит, і використовувати його як основу для назви сутності. Якщо запит базується на атрибутах інших сутностей, варто додати їх до назви таблиці через `by`. Наприклад, `hotels_by_poi`.

Далі необхідно визначити первинний ключ таблиці, додавши колонки ключа розділу (partition key) на основі атрибутів запиту і колонки кластеризації для гарантії унікальності та бажаного порядку сортування.

Проєктування первинного ключа є надзвичайно важливим, оскільки воно визначатиме, скільки даних зберігатиметься в кожному розділі і як ці дані організовані на диску, що, у свою чергу, впливатиме на швидкість обробки запитів у Cassandra.

Завершіть кожну таблицю, додавши всі інші атрибути, визначені в запиті. Якщо для кожного елемента ключа розділу значення цих атрибутів буде однаковим, позначте колонку як статичну (static).

Для представлення логічних моделей скористаємося нотацією, запропонованою Артемом Чеботко. Ця схема дозволяє візуалізувати зв’язки між запитами і таблицями. На схемі кожна таблиця відображається із заголовком і списком колонок. Колонки первинного ключа позначаються символами, наприклад, **K** для колонок ключа розділу і **C↑** або **C↓** для колонок кластеризації. Лінії між таблицями вказують на запити, для підтримки яких розроблена кожна таблиця.

## Логічна модель даних для готелів

Перший запит, Q1, – це пошук готелів поблизу певної точки інтересу. Отже, назвемо цю таблицю `hotels_by_poi`. Оскільки пошук базується на назві точки інтересу, вона має бути частиною первинного ключа. Також, імовірно, в одному місці може бути кілька готелів, тому додаємо `hotel_id` як колонку кластеризації.

Другий запит, Q2, потрібен для отримання інформації про конкретний готель. Таблиця `hotels_by_poi` містить лише базові дані про готелі, тому для отримання деталей потрібна таблиця `hotels`, яка використовує `hotel_id` як ключ.

Запит Q3, по суті, є зворотним для Q1 — він передбачає пошук точок інтересу поблизу готелю. Для цього додаємо таблицю `pois_by_hotel` з poi_name як ключем кластеризації.

Для підтримки запиту Q4, що дозволяє знайти доступні номери в певні дати, використовуємо таблицю `available_rooms_by_hotel_date`. Використовуючи `hotel_id` як ключ розділу, а `date` як колонку кластеризації, можна виконувати швидкий пошук по діапазону дат.

Нарешті, для Q5 додаємо таблицю `amenities_by_room`, що дозволить користувачам переглядати доступні зручності номерів у готелі для обраних дат.

## Логічна модель даних для бронювань

Розглянемо запити для бронювань. Модель даних для бронювань у Cassandra передбачає денормалізований дизайн, де одні й ті самі дані можуть бути присутні в кількох таблицях з різними ключами.

Запит Q6 реалізується за допомогою таблиці `reservations_by_guest`, яка дозволяє знайти бронювання за ім’ям гостя. Через можливу неунікальність імен, `guest_id` додається як колонка кластеризації для ідентифікації запису.

Запити Q8 та Q9 показують, що дані потрібні не лише для користувачів, але й для персоналу та аналітичних команд. Персонал готелю може використовувати запит Q8 для отримання даних про майбутні бронювання на конкретну дату.

Також створюється таблиця `guests`, що забезпечує централізоване зберігання інформації про гостей. Це окрема таблиця з унікальними ідентифікаторами записів про гостей, адже імена можуть повторюватися. Така таблиця часто є частиною окремого додатка для управління клієнтами.

## Шаблони і антишаблони

Як і в інших областях проєктування, у Cassandra є відомі шаблони й антишаблони моделювання даних. Найпоширенішим шаблоном є шаблон широкого розділу (wide partition pattern).

Шаблон часових рядів є розширенням широкого розділу. У ньому дані вимірювань на певні інтервали часу зберігаються у широкому розділі, де час вимірювання використовується як частина ключа. Такий шаблон часто використовується у сферах бізнес-аналітики, керування даними сенсорів та наукових експериментів.

Наприклад, у банківській програмі можна зберігати кожну транзакцію як рядок з міткою часу, а обчислення поточного балансу виконувати на рівні застосунку. Це допомагає уникнути змагальності при оновленні балансу.

Антишаблон черги - одна з пасток проєктування. Він полягає у зберіганні елементів черги з мітками часу у широкому розділі. Такий дизайн спирається на видалення даних, що створює "надгробки" (tombstones), які Cassandra повинна обходити. Це може призвести до зниження продуктивності читання з часом.

Цей антишаблон показує, що будь-який дизайн, який залежить від частого видалення даних, може бути неефективним у Cassandra.