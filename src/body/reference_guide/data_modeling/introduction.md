# Вступ

Apache Cassandra зберігає дані в таблицях, кожна з яких складається з рядків і стовпців. Для запитів до даних у таблицях використовується мова запитів CQL (Cassandra Query Language). Моделювання даних в Apache Cassandra побудовано навколо запитів і оптимізовано для їх виконання. Cassandra не підтримує реляційне моделювання даних, яке призначене для реляційних баз даних.

## Що таке моделювання даних?
Моделювання даних — це процес визначення сутностей і їх зв'язків. У реляційних базах даних дані розміщуються в нормалізованих таблицях, а для посилань на пов'язані дані в інших таблицях використовуються зовнішні ключі. Запити, які виконує програма, визначають структуру таблиць, і зв'язувані дані запитуються через об'єднання таблиць (JOIN).

У Cassandra моделювання даних є орієнтованим на запити. Шаблони доступу до даних і запити програми визначають структуру та організацію даних, які використовуються для проектування таблиць бази даних.

Дані моделюються навколо конкретних запитів. Запити найкраще проєктувати так, щоб вони зверталися до однієї таблиці, що означає, що всі сутності, що беруть участь у запиті, повинні знаходитися в одній таблиці для швидкого доступу (чтення) даних. Дані моделюються так, щоб найкраще підходити до запиту або набору запитів. Таблиця може містити одну чи кілька сутностей, що найкраще відповідають запиту. Оскільки сутності зазвичай мають зв'язки між собою, а запити можуть стосуватися сутностей із зв'язками, одна й та ж сутність може бути включена в кілька таблиць.

## Моделювання, орієнтоване на запити
На відміну від реляційної моделі баз даних, де запити використовують об'єднання таблиць для отримання даних з кількох таблиць, Cassandra не підтримує об'єднання (JOIN), тому всі необхідні поля (стовпці) повинні бути згруповані в одній таблиці. Оскільки кожен запит підтримується таблицею, дані дублюються в кількох таблицях у процесі, відомому як денормалізація. Дублювання даних і висока пропускна здатність запису використовуються для досягнення високої продуктивності читання.

## Цілі
Вибір основного ключа і ключа партиції важливий для рівномірного розподілу даних по кластеру. Також важливо мінімізувати кількість партицій, що читаються за запитом, оскільки різні партиції можуть знаходитись на різних вузлах, і координатору доведеться надсилати запит до кожного вузла, що збільшує накладні витрати і затримки. Навіть якщо різні партиції для запиту знаходяться на тому ж вузлі, менша кількість партицій робить запит ефективнішим.

## Партиції
Apache Cassandra — це розподілена база даних, яка зберігає дані по кластеру вузлів. Ключ партиції використовується для розподілу даних між вузлами. Cassandra розподіляє дані по вузлах кластеру, використовуючи варіант стійкого хешування для розподілу даних. Хешування — це техніка, яка використовується для відображення даних, за якою функція хешування генерує хеш-значення (або просто хеш), що зберігається в хеш-таблиці. Ключ партиції генерується з першого поля основного ключа. Дані, розподілені в хеш-таблицях за допомогою ключів партиції, забезпечують швидкий пошук. Чим менше партицій використовується для запиту, тим швидший час відгуку запиту.

Приклад партиціювання: розглянемо таблицю `t`, в якій `id` — єдине поле в основному ключі.

```sql
CREATE TABLE t (
   id int,
   k int,
   v text,
   PRIMARY KEY (id)
);
```
Ключ партиції генерується з основного ключа `id` для розподілу даних по вузлах кластеру.

Розглянемо варіант таблиці `t`, де є два поля, що складають основний ключ, що утворює складений (композитний) основний ключ.

```sql
Copy code
CREATE TABLE t (
   id int,
   c text,
   k int,
   v text,
   PRIMARY KEY (id,c)
);
```

Для таблиці `t` з композитним основним ключем перше поле `id` використовується для генерації ключа партиції, а друге поле `c` є ключем кластеризації, який використовується для сортування в межах партиції. Використання ключів кластеризації для сортування даних робить отримання сусідніх даних ефективнішим.

Загалом, перше поле або компонент основного ключа хешується для генерації ключа партиції, а решта полів або компонентів є ключами кластеризації, що використовуються для сортування даних в межах партиції. Розподілення даних по партиціях підвищує ефективність читання та запису. Інші поля, що не є основними, можуть бути індексовані окремо для подальшого підвищення продуктивності запитів.

Ключ партиції може бути згенерований з кількох полів, якщо вони групуються як перший компонент основного ключа. Як ще один варіант таблиці `t`, розглянемо таблицю, де перший компонент основного ключа складається з двох полів, згрупованих в дужки.

```sql
Copy code
CREATE TABLE t (
   id1 int,
   id2 int,
   c1 text,
   c2 text,
   k int,
   v text,
   PRIMARY KEY ((id1,id2),c1,c2)
);
```

Для таблиці `t` перший компонент основного ключа, що складається з полів `id1` та `id2`, використовується для генерації ключа партиції, а решта полів `c1` і `c2` є ключами кластеризації, що використовуються для сортування в межах партиції.

## Порівняння з реляційною моделлю даних
Реляційні бази даних зберігають дані в таблицях, які мають зв'язки з іншими таблицями через зовнішні ключі. Підхід реляційної бази даних до моделювання даних є орієнтованим на таблиці. Для отримання даних з кількох таблиць, що мають зв'язок між собою, реляційні запити використовують об'єднання таблиць (JOIN). Apache Cassandra не має концепції зовнішніх ключів чи реляційної цілісності. Модель даних Cassandra побудована навколо проектування ефективних запитів, що не включають кілька таблиць. Реляційні бази даних нормалізують дані для уникнення дублювання. У свою чергу, Cassandra денормалізує дані, дублюючи їх у кількох таблицях для моделі даних, орієнтованої на запити. Якщо модель даних Cassandra не може повністю інтегрувати складність відносин між різними сутностями для певного запиту, можна використовувати клієнтські об'єднання в коді програми.

## Приклади моделювання даних
Наприклад, набір даних журналів (`magazine`) складається з даних для журналів з атрибутами, такими як ідентифікатор журналу, назва журналу, частота публікацій, дата публікації і видавець. Базовий запит (Q1) для даних журналів — це список всіх назв журналів з вказаною частотою публікацій. Оскільки не всі атрибути даних необхідні для Q1, модель даних містить лише `id` (як ключ партиції), назву журналу та частоту публікацій, як показано на малюнку.

![q1](q1.jpg)

Інший запит (Q2) полягає в отриманні всіх назв журналів за видавцем (`publisher`). Для Q2 модель даних міститиме додатковий атрибут видавця для партиційного ключа. Ідентифікатор стане ключем кластеризації для сортування в межах партиції. Модель даних для Q2 зображена на рисунку.

![q2](q2.jpg)

Ці приклади демонструють, як структурування даних у Cassandra оптимізується для конкретних запитів, використовуючи партиційні та кластеризаційні ключі для досягнення швидкого доступу до даних, залежно від того, який тип запиту буде виконано.

## Дизайн схеми

Після створення концептуальної моделі даних можна спроектувати схему для запиту. Для Q1 наступну схему можна використати:

```sql
Copy code
CREATE TABLE magazine_name (id int PRIMARY KEY, name text, publicationFrequency text)
```

Для Q2 схема визначатиме ключ кластеризації для сортування.

```sql
Copy code
CREATE TABLE magazine_publisher (publisher text, id int, name text, publicationFrequency text,
PRIMARY KEY (publisher, id)) WITH CLUSTERING ORDER BY (id DESC)
```

## Аналіз моделі даних

Модель даних — це концептуальна модель, яку необхідно аналізувати та оптимізувати з огляду на вимоги до зберігання даних, ємності, надмірності та узгодженості. Під час аналізу модель може потребувати змін. Основні параметри, що враховуються під час аналізу моделі даних:

- Розмір партиції
- Надмірність даних
- Місце на диску
- Легкі транзакції (LWT)

Основні параметри для вимірювання розміру партиції — це кількість значень у партиції та розмір партиції на диску. Хоча вимоги до цих параметрів можуть змінюватися в залежності від застосунку, загальна рекомендація — зберігати кількість значень у партиції менше за 100 000 і розмір партиції на диску менше за 100 МБ.

Надмірність даних, така як дубльовані дані в таблицях і кілька копій партицій, є очікуваною в моделі даних, але її потрібно враховувати і зводити до мінімуму. Транзакції типу LWT (наприклад, операції "порівняти і встановити", умовне оновлення) можуть вплинути на продуктивність, тому запити, що використовують LWT, повинні бути обмежені до мінімуму.

## Використання матеріалізованих уявлень (Materialized Views)

*Матеріалізовані уявлення (MVs) є експериментальними з версії 4.0.*

Матеріалізовані уявлення можуть бути використані для реалізації кількох запитів до однієї таблиці. Матеріалізоване уявлення — це таблиця, створена на основі даних іншої таблиці, основної таблиці, з новим основним ключем і новими властивостями. Зміни в даних основної таблиці автоматично додаються та оновлюються в матеріалізованому уявленні. Для різних запитів можна використовувати матеріалізовані уявлення, оскільки їх основний ключ відрізняється від основного ключа базової таблиці. Запити оптимізуються через визначення основного ключа матеріалізованого уявлення.

Таким чином, використання матеріалізованих уявлень дозволяє оптимізувати запити для конкретних потреб, зберігаючи швидкість доступу до даних.